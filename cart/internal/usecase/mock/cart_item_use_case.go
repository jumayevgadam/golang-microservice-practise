// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"cart/internal/domain"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartItemUseCaseMock implements mm_usecase.CartItemUseCase
type CartItemUseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCartItem          func(ctx context.Context, cartItem domain.CartItem) (err error)
	funcAddCartItemOrigin    string
	inspectFuncAddCartItem   func(ctx context.Context, cartItem domain.CartItem)
	afterAddCartItemCounter  uint64
	beforeAddCartItemCounter uint64
	AddCartItemMock          mCartItemUseCaseMockAddCartItem

	funcClearCartItems          func(ctx context.Context, userID domain.UserID) (err error)
	funcClearCartItemsOrigin    string
	inspectFuncClearCartItems   func(ctx context.Context, userID domain.UserID)
	afterClearCartItemsCounter  uint64
	beforeClearCartItemsCounter uint64
	ClearCartItemsMock          mCartItemUseCaseMockClearCartItems

	funcDeleteCartItem          func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error)
	funcDeleteCartItemOrigin    string
	inspectFuncDeleteCartItem   func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)
	afterDeleteCartItemCounter  uint64
	beforeDeleteCartItemCounter uint64
	DeleteCartItemMock          mCartItemUseCaseMockDeleteCartItem

	funcListCartItems          func(ctx context.Context, userID domain.UserID) (l1 domain.ListCartItems, err error)
	funcListCartItemsOrigin    string
	inspectFuncListCartItems   func(ctx context.Context, userID domain.UserID)
	afterListCartItemsCounter  uint64
	beforeListCartItemsCounter uint64
	ListCartItemsMock          mCartItemUseCaseMockListCartItems
}

// NewCartItemUseCaseMock returns a mock for mm_usecase.CartItemUseCase
func NewCartItemUseCaseMock(t minimock.Tester) *CartItemUseCaseMock {
	m := &CartItemUseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCartItemMock = mCartItemUseCaseMockAddCartItem{mock: m}
	m.AddCartItemMock.callArgs = []*CartItemUseCaseMockAddCartItemParams{}

	m.ClearCartItemsMock = mCartItemUseCaseMockClearCartItems{mock: m}
	m.ClearCartItemsMock.callArgs = []*CartItemUseCaseMockClearCartItemsParams{}

	m.DeleteCartItemMock = mCartItemUseCaseMockDeleteCartItem{mock: m}
	m.DeleteCartItemMock.callArgs = []*CartItemUseCaseMockDeleteCartItemParams{}

	m.ListCartItemsMock = mCartItemUseCaseMockListCartItems{mock: m}
	m.ListCartItemsMock.callArgs = []*CartItemUseCaseMockListCartItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartItemUseCaseMockAddCartItem struct {
	optional           bool
	mock               *CartItemUseCaseMock
	defaultExpectation *CartItemUseCaseMockAddCartItemExpectation
	expectations       []*CartItemUseCaseMockAddCartItemExpectation

	callArgs []*CartItemUseCaseMockAddCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemUseCaseMockAddCartItemExpectation specifies expectation struct of the CartItemUseCase.AddCartItem
type CartItemUseCaseMockAddCartItemExpectation struct {
	mock               *CartItemUseCaseMock
	params             *CartItemUseCaseMockAddCartItemParams
	paramPtrs          *CartItemUseCaseMockAddCartItemParamPtrs
	expectationOrigins CartItemUseCaseMockAddCartItemExpectationOrigins
	results            *CartItemUseCaseMockAddCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartItemUseCaseMockAddCartItemParams contains parameters of the CartItemUseCase.AddCartItem
type CartItemUseCaseMockAddCartItemParams struct {
	ctx      context.Context
	cartItem domain.CartItem
}

// CartItemUseCaseMockAddCartItemParamPtrs contains pointers to parameters of the CartItemUseCase.AddCartItem
type CartItemUseCaseMockAddCartItemParamPtrs struct {
	ctx      *context.Context
	cartItem *domain.CartItem
}

// CartItemUseCaseMockAddCartItemResults contains results of the CartItemUseCase.AddCartItem
type CartItemUseCaseMockAddCartItemResults struct {
	err error
}

// CartItemUseCaseMockAddCartItemOrigins contains origins of expectations of the CartItemUseCase.AddCartItem
type CartItemUseCaseMockAddCartItemExpectationOrigins struct {
	origin         string
	originCtx      string
	originCartItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Optional() *mCartItemUseCaseMockAddCartItem {
	mmAddCartItem.optional = true
	return mmAddCartItem
}

// Expect sets up expected params for CartItemUseCase.AddCartItem
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Expect(ctx context.Context, cartItem domain.CartItem) *mCartItemUseCaseMockAddCartItem {
	if mmAddCartItem.mock.funcAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Set")
	}

	if mmAddCartItem.defaultExpectation == nil {
		mmAddCartItem.defaultExpectation = &CartItemUseCaseMockAddCartItemExpectation{}
	}

	if mmAddCartItem.defaultExpectation.paramPtrs != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by ExpectParams functions")
	}

	mmAddCartItem.defaultExpectation.params = &CartItemUseCaseMockAddCartItemParams{ctx, cartItem}
	mmAddCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCartItem.expectations {
		if minimock.Equal(e.params, mmAddCartItem.defaultExpectation.params) {
			mmAddCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCartItem.defaultExpectation.params)
		}
	}

	return mmAddCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartItemUseCase.AddCartItem
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) ExpectCtxParam1(ctx context.Context) *mCartItemUseCaseMockAddCartItem {
	if mmAddCartItem.mock.funcAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Set")
	}

	if mmAddCartItem.defaultExpectation == nil {
		mmAddCartItem.defaultExpectation = &CartItemUseCaseMockAddCartItemExpectation{}
	}

	if mmAddCartItem.defaultExpectation.params != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Expect")
	}

	if mmAddCartItem.defaultExpectation.paramPtrs == nil {
		mmAddCartItem.defaultExpectation.paramPtrs = &CartItemUseCaseMockAddCartItemParamPtrs{}
	}
	mmAddCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddCartItem
}

// ExpectCartItemParam2 sets up expected param cartItem for CartItemUseCase.AddCartItem
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) ExpectCartItemParam2(cartItem domain.CartItem) *mCartItemUseCaseMockAddCartItem {
	if mmAddCartItem.mock.funcAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Set")
	}

	if mmAddCartItem.defaultExpectation == nil {
		mmAddCartItem.defaultExpectation = &CartItemUseCaseMockAddCartItemExpectation{}
	}

	if mmAddCartItem.defaultExpectation.params != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Expect")
	}

	if mmAddCartItem.defaultExpectation.paramPtrs == nil {
		mmAddCartItem.defaultExpectation.paramPtrs = &CartItemUseCaseMockAddCartItemParamPtrs{}
	}
	mmAddCartItem.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmAddCartItem.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmAddCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartItemUseCase.AddCartItem
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Inspect(f func(ctx context.Context, cartItem domain.CartItem)) *mCartItemUseCaseMockAddCartItem {
	if mmAddCartItem.mock.inspectFuncAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("Inspect function is already set for CartItemUseCaseMock.AddCartItem")
	}

	mmAddCartItem.mock.inspectFuncAddCartItem = f

	return mmAddCartItem
}

// Return sets up results that will be returned by CartItemUseCase.AddCartItem
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Return(err error) *CartItemUseCaseMock {
	if mmAddCartItem.mock.funcAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Set")
	}

	if mmAddCartItem.defaultExpectation == nil {
		mmAddCartItem.defaultExpectation = &CartItemUseCaseMockAddCartItemExpectation{mock: mmAddCartItem.mock}
	}
	mmAddCartItem.defaultExpectation.results = &CartItemUseCaseMockAddCartItemResults{err}
	mmAddCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCartItem.mock
}

// Set uses given function f to mock the CartItemUseCase.AddCartItem method
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Set(f func(ctx context.Context, cartItem domain.CartItem) (err error)) *CartItemUseCaseMock {
	if mmAddCartItem.defaultExpectation != nil {
		mmAddCartItem.mock.t.Fatalf("Default expectation is already set for the CartItemUseCase.AddCartItem method")
	}

	if len(mmAddCartItem.expectations) > 0 {
		mmAddCartItem.mock.t.Fatalf("Some expectations are already set for the CartItemUseCase.AddCartItem method")
	}

	mmAddCartItem.mock.funcAddCartItem = f
	mmAddCartItem.mock.funcAddCartItemOrigin = minimock.CallerInfo(1)
	return mmAddCartItem.mock
}

// When sets expectation for the CartItemUseCase.AddCartItem which will trigger the result defined by the following
// Then helper
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) When(ctx context.Context, cartItem domain.CartItem) *CartItemUseCaseMockAddCartItemExpectation {
	if mmAddCartItem.mock.funcAddCartItem != nil {
		mmAddCartItem.mock.t.Fatalf("CartItemUseCaseMock.AddCartItem mock is already set by Set")
	}

	expectation := &CartItemUseCaseMockAddCartItemExpectation{
		mock:               mmAddCartItem.mock,
		params:             &CartItemUseCaseMockAddCartItemParams{ctx, cartItem},
		expectationOrigins: CartItemUseCaseMockAddCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCartItem.expectations = append(mmAddCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartItemUseCase.AddCartItem return parameters for the expectation previously defined by the When method
func (e *CartItemUseCaseMockAddCartItemExpectation) Then(err error) *CartItemUseCaseMock {
	e.results = &CartItemUseCaseMockAddCartItemResults{err}
	return e.mock
}

// Times sets number of times CartItemUseCase.AddCartItem should be invoked
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Times(n uint64) *mCartItemUseCaseMockAddCartItem {
	if n == 0 {
		mmAddCartItem.mock.t.Fatalf("Times of CartItemUseCaseMock.AddCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCartItem.expectedInvocations, n)
	mmAddCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCartItem
}

func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) invocationsDone() bool {
	if len(mmAddCartItem.expectations) == 0 && mmAddCartItem.defaultExpectation == nil && mmAddCartItem.mock.funcAddCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCartItem.mock.afterAddCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCartItem implements mm_usecase.CartItemUseCase
func (mmAddCartItem *CartItemUseCaseMock) AddCartItem(ctx context.Context, cartItem domain.CartItem) (err error) {
	mm_atomic.AddUint64(&mmAddCartItem.beforeAddCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCartItem.afterAddCartItemCounter, 1)

	mmAddCartItem.t.Helper()

	if mmAddCartItem.inspectFuncAddCartItem != nil {
		mmAddCartItem.inspectFuncAddCartItem(ctx, cartItem)
	}

	mm_params := CartItemUseCaseMockAddCartItemParams{ctx, cartItem}

	// Record call args
	mmAddCartItem.AddCartItemMock.mutex.Lock()
	mmAddCartItem.AddCartItemMock.callArgs = append(mmAddCartItem.AddCartItemMock.callArgs, &mm_params)
	mmAddCartItem.AddCartItemMock.mutex.Unlock()

	for _, e := range mmAddCartItem.AddCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCartItem.AddCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCartItem.AddCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCartItem.AddCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddCartItem.AddCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartItemUseCaseMockAddCartItemParams{ctx, cartItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddCartItem.t.Errorf("CartItemUseCaseMock.AddCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCartItem.AddCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmAddCartItem.t.Errorf("CartItemUseCaseMock.AddCartItem got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCartItem.AddCartItemMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCartItem.t.Errorf("CartItemUseCaseMock.AddCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCartItem.AddCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCartItem.AddCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCartItem.t.Fatal("No results are set for the CartItemUseCaseMock.AddCartItem")
		}
		return (*mm_results).err
	}
	if mmAddCartItem.funcAddCartItem != nil {
		return mmAddCartItem.funcAddCartItem(ctx, cartItem)
	}
	mmAddCartItem.t.Fatalf("Unexpected call to CartItemUseCaseMock.AddCartItem. %v %v", ctx, cartItem)
	return
}

// AddCartItemAfterCounter returns a count of finished CartItemUseCaseMock.AddCartItem invocations
func (mmAddCartItem *CartItemUseCaseMock) AddCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCartItem.afterAddCartItemCounter)
}

// AddCartItemBeforeCounter returns a count of CartItemUseCaseMock.AddCartItem invocations
func (mmAddCartItem *CartItemUseCaseMock) AddCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCartItem.beforeAddCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartItemUseCaseMock.AddCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCartItem *mCartItemUseCaseMockAddCartItem) Calls() []*CartItemUseCaseMockAddCartItemParams {
	mmAddCartItem.mutex.RLock()

	argCopy := make([]*CartItemUseCaseMockAddCartItemParams, len(mmAddCartItem.callArgs))
	copy(argCopy, mmAddCartItem.callArgs)

	mmAddCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddCartItemDone returns true if the count of the AddCartItem invocations corresponds
// the number of defined expectations
func (m *CartItemUseCaseMock) MinimockAddCartItemDone() bool {
	if m.AddCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCartItemMock.invocationsDone()
}

// MinimockAddCartItemInspect logs each unmet expectation
func (m *CartItemUseCaseMock) MinimockAddCartItemInspect() {
	for _, e := range m.AddCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemUseCaseMock.AddCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCartItemCounter := mm_atomic.LoadUint64(&m.afterAddCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCartItemMock.defaultExpectation != nil && afterAddCartItemCounter < 1 {
		if m.AddCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemUseCaseMock.AddCartItem at\n%s", m.AddCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemUseCaseMock.AddCartItem at\n%s with params: %#v", m.AddCartItemMock.defaultExpectation.expectationOrigins.origin, *m.AddCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCartItem != nil && afterAddCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartItemUseCaseMock.AddCartItem at\n%s", m.funcAddCartItemOrigin)
	}

	if !m.AddCartItemMock.invocationsDone() && afterAddCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemUseCaseMock.AddCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCartItemMock.expectedInvocations), m.AddCartItemMock.expectedInvocationsOrigin, afterAddCartItemCounter)
	}
}

type mCartItemUseCaseMockClearCartItems struct {
	optional           bool
	mock               *CartItemUseCaseMock
	defaultExpectation *CartItemUseCaseMockClearCartItemsExpectation
	expectations       []*CartItemUseCaseMockClearCartItemsExpectation

	callArgs []*CartItemUseCaseMockClearCartItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemUseCaseMockClearCartItemsExpectation specifies expectation struct of the CartItemUseCase.ClearCartItems
type CartItemUseCaseMockClearCartItemsExpectation struct {
	mock               *CartItemUseCaseMock
	params             *CartItemUseCaseMockClearCartItemsParams
	paramPtrs          *CartItemUseCaseMockClearCartItemsParamPtrs
	expectationOrigins CartItemUseCaseMockClearCartItemsExpectationOrigins
	results            *CartItemUseCaseMockClearCartItemsResults
	returnOrigin       string
	Counter            uint64
}

// CartItemUseCaseMockClearCartItemsParams contains parameters of the CartItemUseCase.ClearCartItems
type CartItemUseCaseMockClearCartItemsParams struct {
	ctx    context.Context
	userID domain.UserID
}

// CartItemUseCaseMockClearCartItemsParamPtrs contains pointers to parameters of the CartItemUseCase.ClearCartItems
type CartItemUseCaseMockClearCartItemsParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
}

// CartItemUseCaseMockClearCartItemsResults contains results of the CartItemUseCase.ClearCartItems
type CartItemUseCaseMockClearCartItemsResults struct {
	err error
}

// CartItemUseCaseMockClearCartItemsOrigins contains origins of expectations of the CartItemUseCase.ClearCartItems
type CartItemUseCaseMockClearCartItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Optional() *mCartItemUseCaseMockClearCartItems {
	mmClearCartItems.optional = true
	return mmClearCartItems
}

// Expect sets up expected params for CartItemUseCase.ClearCartItems
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Expect(ctx context.Context, userID domain.UserID) *mCartItemUseCaseMockClearCartItems {
	if mmClearCartItems.mock.funcClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Set")
	}

	if mmClearCartItems.defaultExpectation == nil {
		mmClearCartItems.defaultExpectation = &CartItemUseCaseMockClearCartItemsExpectation{}
	}

	if mmClearCartItems.defaultExpectation.paramPtrs != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by ExpectParams functions")
	}

	mmClearCartItems.defaultExpectation.params = &CartItemUseCaseMockClearCartItemsParams{ctx, userID}
	mmClearCartItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCartItems.expectations {
		if minimock.Equal(e.params, mmClearCartItems.defaultExpectation.params) {
			mmClearCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCartItems.defaultExpectation.params)
		}
	}

	return mmClearCartItems
}

// ExpectCtxParam1 sets up expected param ctx for CartItemUseCase.ClearCartItems
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) ExpectCtxParam1(ctx context.Context) *mCartItemUseCaseMockClearCartItems {
	if mmClearCartItems.mock.funcClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Set")
	}

	if mmClearCartItems.defaultExpectation == nil {
		mmClearCartItems.defaultExpectation = &CartItemUseCaseMockClearCartItemsExpectation{}
	}

	if mmClearCartItems.defaultExpectation.params != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Expect")
	}

	if mmClearCartItems.defaultExpectation.paramPtrs == nil {
		mmClearCartItems.defaultExpectation.paramPtrs = &CartItemUseCaseMockClearCartItemsParamPtrs{}
	}
	mmClearCartItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCartItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCartItems
}

// ExpectUserIDParam2 sets up expected param userID for CartItemUseCase.ClearCartItems
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) ExpectUserIDParam2(userID domain.UserID) *mCartItemUseCaseMockClearCartItems {
	if mmClearCartItems.mock.funcClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Set")
	}

	if mmClearCartItems.defaultExpectation == nil {
		mmClearCartItems.defaultExpectation = &CartItemUseCaseMockClearCartItemsExpectation{}
	}

	if mmClearCartItems.defaultExpectation.params != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Expect")
	}

	if mmClearCartItems.defaultExpectation.paramPtrs == nil {
		mmClearCartItems.defaultExpectation.paramPtrs = &CartItemUseCaseMockClearCartItemsParamPtrs{}
	}
	mmClearCartItems.defaultExpectation.paramPtrs.userID = &userID
	mmClearCartItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCartItems
}

// Inspect accepts an inspector function that has same arguments as the CartItemUseCase.ClearCartItems
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Inspect(f func(ctx context.Context, userID domain.UserID)) *mCartItemUseCaseMockClearCartItems {
	if mmClearCartItems.mock.inspectFuncClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("Inspect function is already set for CartItemUseCaseMock.ClearCartItems")
	}

	mmClearCartItems.mock.inspectFuncClearCartItems = f

	return mmClearCartItems
}

// Return sets up results that will be returned by CartItemUseCase.ClearCartItems
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Return(err error) *CartItemUseCaseMock {
	if mmClearCartItems.mock.funcClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Set")
	}

	if mmClearCartItems.defaultExpectation == nil {
		mmClearCartItems.defaultExpectation = &CartItemUseCaseMockClearCartItemsExpectation{mock: mmClearCartItems.mock}
	}
	mmClearCartItems.defaultExpectation.results = &CartItemUseCaseMockClearCartItemsResults{err}
	mmClearCartItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCartItems.mock
}

// Set uses given function f to mock the CartItemUseCase.ClearCartItems method
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Set(f func(ctx context.Context, userID domain.UserID) (err error)) *CartItemUseCaseMock {
	if mmClearCartItems.defaultExpectation != nil {
		mmClearCartItems.mock.t.Fatalf("Default expectation is already set for the CartItemUseCase.ClearCartItems method")
	}

	if len(mmClearCartItems.expectations) > 0 {
		mmClearCartItems.mock.t.Fatalf("Some expectations are already set for the CartItemUseCase.ClearCartItems method")
	}

	mmClearCartItems.mock.funcClearCartItems = f
	mmClearCartItems.mock.funcClearCartItemsOrigin = minimock.CallerInfo(1)
	return mmClearCartItems.mock
}

// When sets expectation for the CartItemUseCase.ClearCartItems which will trigger the result defined by the following
// Then helper
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) When(ctx context.Context, userID domain.UserID) *CartItemUseCaseMockClearCartItemsExpectation {
	if mmClearCartItems.mock.funcClearCartItems != nil {
		mmClearCartItems.mock.t.Fatalf("CartItemUseCaseMock.ClearCartItems mock is already set by Set")
	}

	expectation := &CartItemUseCaseMockClearCartItemsExpectation{
		mock:               mmClearCartItems.mock,
		params:             &CartItemUseCaseMockClearCartItemsParams{ctx, userID},
		expectationOrigins: CartItemUseCaseMockClearCartItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCartItems.expectations = append(mmClearCartItems.expectations, expectation)
	return expectation
}

// Then sets up CartItemUseCase.ClearCartItems return parameters for the expectation previously defined by the When method
func (e *CartItemUseCaseMockClearCartItemsExpectation) Then(err error) *CartItemUseCaseMock {
	e.results = &CartItemUseCaseMockClearCartItemsResults{err}
	return e.mock
}

// Times sets number of times CartItemUseCase.ClearCartItems should be invoked
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Times(n uint64) *mCartItemUseCaseMockClearCartItems {
	if n == 0 {
		mmClearCartItems.mock.t.Fatalf("Times of CartItemUseCaseMock.ClearCartItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCartItems.expectedInvocations, n)
	mmClearCartItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCartItems
}

func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) invocationsDone() bool {
	if len(mmClearCartItems.expectations) == 0 && mmClearCartItems.defaultExpectation == nil && mmClearCartItems.mock.funcClearCartItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCartItems.mock.afterClearCartItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCartItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCartItems implements mm_usecase.CartItemUseCase
func (mmClearCartItems *CartItemUseCaseMock) ClearCartItems(ctx context.Context, userID domain.UserID) (err error) {
	mm_atomic.AddUint64(&mmClearCartItems.beforeClearCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCartItems.afterClearCartItemsCounter, 1)

	mmClearCartItems.t.Helper()

	if mmClearCartItems.inspectFuncClearCartItems != nil {
		mmClearCartItems.inspectFuncClearCartItems(ctx, userID)
	}

	mm_params := CartItemUseCaseMockClearCartItemsParams{ctx, userID}

	// Record call args
	mmClearCartItems.ClearCartItemsMock.mutex.Lock()
	mmClearCartItems.ClearCartItemsMock.callArgs = append(mmClearCartItems.ClearCartItemsMock.callArgs, &mm_params)
	mmClearCartItems.ClearCartItemsMock.mutex.Unlock()

	for _, e := range mmClearCartItems.ClearCartItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCartItems.ClearCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCartItems.ClearCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCartItems.ClearCartItemsMock.defaultExpectation.params
		mm_want_ptrs := mmClearCartItems.ClearCartItemsMock.defaultExpectation.paramPtrs

		mm_got := CartItemUseCaseMockClearCartItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCartItems.t.Errorf("CartItemUseCaseMock.ClearCartItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartItems.ClearCartItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCartItems.t.Errorf("CartItemUseCaseMock.ClearCartItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCartItems.ClearCartItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCartItems.t.Errorf("CartItemUseCaseMock.ClearCartItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCartItems.ClearCartItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCartItems.ClearCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCartItems.t.Fatal("No results are set for the CartItemUseCaseMock.ClearCartItems")
		}
		return (*mm_results).err
	}
	if mmClearCartItems.funcClearCartItems != nil {
		return mmClearCartItems.funcClearCartItems(ctx, userID)
	}
	mmClearCartItems.t.Fatalf("Unexpected call to CartItemUseCaseMock.ClearCartItems. %v %v", ctx, userID)
	return
}

// ClearCartItemsAfterCounter returns a count of finished CartItemUseCaseMock.ClearCartItems invocations
func (mmClearCartItems *CartItemUseCaseMock) ClearCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartItems.afterClearCartItemsCounter)
}

// ClearCartItemsBeforeCounter returns a count of CartItemUseCaseMock.ClearCartItems invocations
func (mmClearCartItems *CartItemUseCaseMock) ClearCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCartItems.beforeClearCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CartItemUseCaseMock.ClearCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCartItems *mCartItemUseCaseMockClearCartItems) Calls() []*CartItemUseCaseMockClearCartItemsParams {
	mmClearCartItems.mutex.RLock()

	argCopy := make([]*CartItemUseCaseMockClearCartItemsParams, len(mmClearCartItems.callArgs))
	copy(argCopy, mmClearCartItems.callArgs)

	mmClearCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartItemsDone returns true if the count of the ClearCartItems invocations corresponds
// the number of defined expectations
func (m *CartItemUseCaseMock) MinimockClearCartItemsDone() bool {
	if m.ClearCartItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartItemsMock.invocationsDone()
}

// MinimockClearCartItemsInspect logs each unmet expectation
func (m *CartItemUseCaseMock) MinimockClearCartItemsInspect() {
	for _, e := range m.ClearCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ClearCartItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartItemsCounter := mm_atomic.LoadUint64(&m.afterClearCartItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartItemsMock.defaultExpectation != nil && afterClearCartItemsCounter < 1 {
		if m.ClearCartItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ClearCartItems at\n%s", m.ClearCartItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ClearCartItems at\n%s with params: %#v", m.ClearCartItemsMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCartItems != nil && afterClearCartItemsCounter < 1 {
		m.t.Errorf("Expected call to CartItemUseCaseMock.ClearCartItems at\n%s", m.funcClearCartItemsOrigin)
	}

	if !m.ClearCartItemsMock.invocationsDone() && afterClearCartItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemUseCaseMock.ClearCartItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartItemsMock.expectedInvocations), m.ClearCartItemsMock.expectedInvocationsOrigin, afterClearCartItemsCounter)
	}
}

type mCartItemUseCaseMockDeleteCartItem struct {
	optional           bool
	mock               *CartItemUseCaseMock
	defaultExpectation *CartItemUseCaseMockDeleteCartItemExpectation
	expectations       []*CartItemUseCaseMockDeleteCartItemExpectation

	callArgs []*CartItemUseCaseMockDeleteCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemUseCaseMockDeleteCartItemExpectation specifies expectation struct of the CartItemUseCase.DeleteCartItem
type CartItemUseCaseMockDeleteCartItemExpectation struct {
	mock               *CartItemUseCaseMock
	params             *CartItemUseCaseMockDeleteCartItemParams
	paramPtrs          *CartItemUseCaseMockDeleteCartItemParamPtrs
	expectationOrigins CartItemUseCaseMockDeleteCartItemExpectationOrigins
	results            *CartItemUseCaseMockDeleteCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartItemUseCaseMockDeleteCartItemParams contains parameters of the CartItemUseCase.DeleteCartItem
type CartItemUseCaseMockDeleteCartItemParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SkuID
}

// CartItemUseCaseMockDeleteCartItemParamPtrs contains pointers to parameters of the CartItemUseCase.DeleteCartItem
type CartItemUseCaseMockDeleteCartItemParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SkuID
}

// CartItemUseCaseMockDeleteCartItemResults contains results of the CartItemUseCase.DeleteCartItem
type CartItemUseCaseMockDeleteCartItemResults struct {
	err error
}

// CartItemUseCaseMockDeleteCartItemOrigins contains origins of expectations of the CartItemUseCase.DeleteCartItem
type CartItemUseCaseMockDeleteCartItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Optional() *mCartItemUseCaseMockDeleteCartItem {
	mmDeleteCartItem.optional = true
	return mmDeleteCartItem
}

// Expect sets up expected params for CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Expect(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *mCartItemUseCaseMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartItemUseCaseMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by ExpectParams functions")
	}

	mmDeleteCartItem.defaultExpectation.params = &CartItemUseCaseMockDeleteCartItemParams{ctx, userID, skuID}
	mmDeleteCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCartItem.expectations {
		if minimock.Equal(e.params, mmDeleteCartItem.defaultExpectation.params) {
			mmDeleteCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCartItem.defaultExpectation.params)
		}
	}

	return mmDeleteCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) ExpectCtxParam1(ctx context.Context) *mCartItemUseCaseMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartItemUseCaseMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartItemUseCaseMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// ExpectUserIDParam2 sets up expected param userID for CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) ExpectUserIDParam2(userID domain.UserID) *mCartItemUseCaseMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartItemUseCaseMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartItemUseCaseMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// ExpectSkuIDParam3 sets up expected param skuID for CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) ExpectSkuIDParam3(skuID domain.SkuID) *mCartItemUseCaseMockDeleteCartItem {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartItemUseCaseMockDeleteCartItemExpectation{}
	}

	if mmDeleteCartItem.defaultExpectation.params != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Expect")
	}

	if mmDeleteCartItem.defaultExpectation.paramPtrs == nil {
		mmDeleteCartItem.defaultExpectation.paramPtrs = &CartItemUseCaseMockDeleteCartItemParamPtrs{}
	}
	mmDeleteCartItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteCartItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)) *mCartItemUseCaseMockDeleteCartItem {
	if mmDeleteCartItem.mock.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("Inspect function is already set for CartItemUseCaseMock.DeleteCartItem")
	}

	mmDeleteCartItem.mock.inspectFuncDeleteCartItem = f

	return mmDeleteCartItem
}

// Return sets up results that will be returned by CartItemUseCase.DeleteCartItem
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Return(err error) *CartItemUseCaseMock {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	if mmDeleteCartItem.defaultExpectation == nil {
		mmDeleteCartItem.defaultExpectation = &CartItemUseCaseMockDeleteCartItemExpectation{mock: mmDeleteCartItem.mock}
	}
	mmDeleteCartItem.defaultExpectation.results = &CartItemUseCaseMockDeleteCartItemResults{err}
	mmDeleteCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem.mock
}

// Set uses given function f to mock the CartItemUseCase.DeleteCartItem method
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error)) *CartItemUseCaseMock {
	if mmDeleteCartItem.defaultExpectation != nil {
		mmDeleteCartItem.mock.t.Fatalf("Default expectation is already set for the CartItemUseCase.DeleteCartItem method")
	}

	if len(mmDeleteCartItem.expectations) > 0 {
		mmDeleteCartItem.mock.t.Fatalf("Some expectations are already set for the CartItemUseCase.DeleteCartItem method")
	}

	mmDeleteCartItem.mock.funcDeleteCartItem = f
	mmDeleteCartItem.mock.funcDeleteCartItemOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem.mock
}

// When sets expectation for the CartItemUseCase.DeleteCartItem which will trigger the result defined by the following
// Then helper
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) When(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *CartItemUseCaseMockDeleteCartItemExpectation {
	if mmDeleteCartItem.mock.funcDeleteCartItem != nil {
		mmDeleteCartItem.mock.t.Fatalf("CartItemUseCaseMock.DeleteCartItem mock is already set by Set")
	}

	expectation := &CartItemUseCaseMockDeleteCartItemExpectation{
		mock:               mmDeleteCartItem.mock,
		params:             &CartItemUseCaseMockDeleteCartItemParams{ctx, userID, skuID},
		expectationOrigins: CartItemUseCaseMockDeleteCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCartItem.expectations = append(mmDeleteCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartItemUseCase.DeleteCartItem return parameters for the expectation previously defined by the When method
func (e *CartItemUseCaseMockDeleteCartItemExpectation) Then(err error) *CartItemUseCaseMock {
	e.results = &CartItemUseCaseMockDeleteCartItemResults{err}
	return e.mock
}

// Times sets number of times CartItemUseCase.DeleteCartItem should be invoked
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Times(n uint64) *mCartItemUseCaseMockDeleteCartItem {
	if n == 0 {
		mmDeleteCartItem.mock.t.Fatalf("Times of CartItemUseCaseMock.DeleteCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCartItem.expectedInvocations, n)
	mmDeleteCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCartItem
}

func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) invocationsDone() bool {
	if len(mmDeleteCartItem.expectations) == 0 && mmDeleteCartItem.defaultExpectation == nil && mmDeleteCartItem.mock.funcDeleteCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCartItem.mock.afterDeleteCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCartItem implements mm_usecase.CartItemUseCase
func (mmDeleteCartItem *CartItemUseCaseMock) DeleteCartItem(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error) {
	mm_atomic.AddUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCartItem.afterDeleteCartItemCounter, 1)

	mmDeleteCartItem.t.Helper()

	if mmDeleteCartItem.inspectFuncDeleteCartItem != nil {
		mmDeleteCartItem.inspectFuncDeleteCartItem(ctx, userID, skuID)
	}

	mm_params := CartItemUseCaseMockDeleteCartItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteCartItem.DeleteCartItemMock.mutex.Lock()
	mmDeleteCartItem.DeleteCartItemMock.callArgs = append(mmDeleteCartItem.DeleteCartItemMock.callArgs, &mm_params)
	mmDeleteCartItem.DeleteCartItemMock.mutex.Unlock()

	for _, e := range mmDeleteCartItem.DeleteCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCartItem.DeleteCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartItemUseCaseMockDeleteCartItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCartItem.t.Errorf("CartItemUseCaseMock.DeleteCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteCartItem.t.Errorf("CartItemUseCaseMock.DeleteCartItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteCartItem.t.Errorf("CartItemUseCaseMock.DeleteCartItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCartItem.t.Errorf("CartItemUseCaseMock.DeleteCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCartItem.DeleteCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCartItem.t.Fatal("No results are set for the CartItemUseCaseMock.DeleteCartItem")
		}
		return (*mm_results).err
	}
	if mmDeleteCartItem.funcDeleteCartItem != nil {
		return mmDeleteCartItem.funcDeleteCartItem(ctx, userID, skuID)
	}
	mmDeleteCartItem.t.Fatalf("Unexpected call to CartItemUseCaseMock.DeleteCartItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteCartItemAfterCounter returns a count of finished CartItemUseCaseMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartItemUseCaseMock) DeleteCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.afterDeleteCartItemCounter)
}

// DeleteCartItemBeforeCounter returns a count of CartItemUseCaseMock.DeleteCartItem invocations
func (mmDeleteCartItem *CartItemUseCaseMock) DeleteCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCartItem.beforeDeleteCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartItemUseCaseMock.DeleteCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCartItem *mCartItemUseCaseMockDeleteCartItem) Calls() []*CartItemUseCaseMockDeleteCartItemParams {
	mmDeleteCartItem.mutex.RLock()

	argCopy := make([]*CartItemUseCaseMockDeleteCartItemParams, len(mmDeleteCartItem.callArgs))
	copy(argCopy, mmDeleteCartItem.callArgs)

	mmDeleteCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartItemDone returns true if the count of the DeleteCartItem invocations corresponds
// the number of defined expectations
func (m *CartItemUseCaseMock) MinimockDeleteCartItemDone() bool {
	if m.DeleteCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartItemMock.invocationsDone()
}

// MinimockDeleteCartItemInspect logs each unmet expectation
func (m *CartItemUseCaseMock) MinimockDeleteCartItemInspect() {
	for _, e := range m.DeleteCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemUseCaseMock.DeleteCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartItemCounter := mm_atomic.LoadUint64(&m.afterDeleteCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartItemMock.defaultExpectation != nil && afterDeleteCartItemCounter < 1 {
		if m.DeleteCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemUseCaseMock.DeleteCartItem at\n%s", m.DeleteCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemUseCaseMock.DeleteCartItem at\n%s with params: %#v", m.DeleteCartItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCartItem != nil && afterDeleteCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartItemUseCaseMock.DeleteCartItem at\n%s", m.funcDeleteCartItemOrigin)
	}

	if !m.DeleteCartItemMock.invocationsDone() && afterDeleteCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemUseCaseMock.DeleteCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartItemMock.expectedInvocations), m.DeleteCartItemMock.expectedInvocationsOrigin, afterDeleteCartItemCounter)
	}
}

type mCartItemUseCaseMockListCartItems struct {
	optional           bool
	mock               *CartItemUseCaseMock
	defaultExpectation *CartItemUseCaseMockListCartItemsExpectation
	expectations       []*CartItemUseCaseMockListCartItemsExpectation

	callArgs []*CartItemUseCaseMockListCartItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemUseCaseMockListCartItemsExpectation specifies expectation struct of the CartItemUseCase.ListCartItems
type CartItemUseCaseMockListCartItemsExpectation struct {
	mock               *CartItemUseCaseMock
	params             *CartItemUseCaseMockListCartItemsParams
	paramPtrs          *CartItemUseCaseMockListCartItemsParamPtrs
	expectationOrigins CartItemUseCaseMockListCartItemsExpectationOrigins
	results            *CartItemUseCaseMockListCartItemsResults
	returnOrigin       string
	Counter            uint64
}

// CartItemUseCaseMockListCartItemsParams contains parameters of the CartItemUseCase.ListCartItems
type CartItemUseCaseMockListCartItemsParams struct {
	ctx    context.Context
	userID domain.UserID
}

// CartItemUseCaseMockListCartItemsParamPtrs contains pointers to parameters of the CartItemUseCase.ListCartItems
type CartItemUseCaseMockListCartItemsParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
}

// CartItemUseCaseMockListCartItemsResults contains results of the CartItemUseCase.ListCartItems
type CartItemUseCaseMockListCartItemsResults struct {
	l1  domain.ListCartItems
	err error
}

// CartItemUseCaseMockListCartItemsOrigins contains origins of expectations of the CartItemUseCase.ListCartItems
type CartItemUseCaseMockListCartItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Optional() *mCartItemUseCaseMockListCartItems {
	mmListCartItems.optional = true
	return mmListCartItems
}

// Expect sets up expected params for CartItemUseCase.ListCartItems
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Expect(ctx context.Context, userID domain.UserID) *mCartItemUseCaseMockListCartItems {
	if mmListCartItems.mock.funcListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Set")
	}

	if mmListCartItems.defaultExpectation == nil {
		mmListCartItems.defaultExpectation = &CartItemUseCaseMockListCartItemsExpectation{}
	}

	if mmListCartItems.defaultExpectation.paramPtrs != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by ExpectParams functions")
	}

	mmListCartItems.defaultExpectation.params = &CartItemUseCaseMockListCartItemsParams{ctx, userID}
	mmListCartItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCartItems.expectations {
		if minimock.Equal(e.params, mmListCartItems.defaultExpectation.params) {
			mmListCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCartItems.defaultExpectation.params)
		}
	}

	return mmListCartItems
}

// ExpectCtxParam1 sets up expected param ctx for CartItemUseCase.ListCartItems
func (mmListCartItems *mCartItemUseCaseMockListCartItems) ExpectCtxParam1(ctx context.Context) *mCartItemUseCaseMockListCartItems {
	if mmListCartItems.mock.funcListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Set")
	}

	if mmListCartItems.defaultExpectation == nil {
		mmListCartItems.defaultExpectation = &CartItemUseCaseMockListCartItemsExpectation{}
	}

	if mmListCartItems.defaultExpectation.params != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Expect")
	}

	if mmListCartItems.defaultExpectation.paramPtrs == nil {
		mmListCartItems.defaultExpectation.paramPtrs = &CartItemUseCaseMockListCartItemsParamPtrs{}
	}
	mmListCartItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCartItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCartItems
}

// ExpectUserIDParam2 sets up expected param userID for CartItemUseCase.ListCartItems
func (mmListCartItems *mCartItemUseCaseMockListCartItems) ExpectUserIDParam2(userID domain.UserID) *mCartItemUseCaseMockListCartItems {
	if mmListCartItems.mock.funcListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Set")
	}

	if mmListCartItems.defaultExpectation == nil {
		mmListCartItems.defaultExpectation = &CartItemUseCaseMockListCartItemsExpectation{}
	}

	if mmListCartItems.defaultExpectation.params != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Expect")
	}

	if mmListCartItems.defaultExpectation.paramPtrs == nil {
		mmListCartItems.defaultExpectation.paramPtrs = &CartItemUseCaseMockListCartItemsParamPtrs{}
	}
	mmListCartItems.defaultExpectation.paramPtrs.userID = &userID
	mmListCartItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListCartItems
}

// Inspect accepts an inspector function that has same arguments as the CartItemUseCase.ListCartItems
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Inspect(f func(ctx context.Context, userID domain.UserID)) *mCartItemUseCaseMockListCartItems {
	if mmListCartItems.mock.inspectFuncListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("Inspect function is already set for CartItemUseCaseMock.ListCartItems")
	}

	mmListCartItems.mock.inspectFuncListCartItems = f

	return mmListCartItems
}

// Return sets up results that will be returned by CartItemUseCase.ListCartItems
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Return(l1 domain.ListCartItems, err error) *CartItemUseCaseMock {
	if mmListCartItems.mock.funcListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Set")
	}

	if mmListCartItems.defaultExpectation == nil {
		mmListCartItems.defaultExpectation = &CartItemUseCaseMockListCartItemsExpectation{mock: mmListCartItems.mock}
	}
	mmListCartItems.defaultExpectation.results = &CartItemUseCaseMockListCartItemsResults{l1, err}
	mmListCartItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCartItems.mock
}

// Set uses given function f to mock the CartItemUseCase.ListCartItems method
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Set(f func(ctx context.Context, userID domain.UserID) (l1 domain.ListCartItems, err error)) *CartItemUseCaseMock {
	if mmListCartItems.defaultExpectation != nil {
		mmListCartItems.mock.t.Fatalf("Default expectation is already set for the CartItemUseCase.ListCartItems method")
	}

	if len(mmListCartItems.expectations) > 0 {
		mmListCartItems.mock.t.Fatalf("Some expectations are already set for the CartItemUseCase.ListCartItems method")
	}

	mmListCartItems.mock.funcListCartItems = f
	mmListCartItems.mock.funcListCartItemsOrigin = minimock.CallerInfo(1)
	return mmListCartItems.mock
}

// When sets expectation for the CartItemUseCase.ListCartItems which will trigger the result defined by the following
// Then helper
func (mmListCartItems *mCartItemUseCaseMockListCartItems) When(ctx context.Context, userID domain.UserID) *CartItemUseCaseMockListCartItemsExpectation {
	if mmListCartItems.mock.funcListCartItems != nil {
		mmListCartItems.mock.t.Fatalf("CartItemUseCaseMock.ListCartItems mock is already set by Set")
	}

	expectation := &CartItemUseCaseMockListCartItemsExpectation{
		mock:               mmListCartItems.mock,
		params:             &CartItemUseCaseMockListCartItemsParams{ctx, userID},
		expectationOrigins: CartItemUseCaseMockListCartItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCartItems.expectations = append(mmListCartItems.expectations, expectation)
	return expectation
}

// Then sets up CartItemUseCase.ListCartItems return parameters for the expectation previously defined by the When method
func (e *CartItemUseCaseMockListCartItemsExpectation) Then(l1 domain.ListCartItems, err error) *CartItemUseCaseMock {
	e.results = &CartItemUseCaseMockListCartItemsResults{l1, err}
	return e.mock
}

// Times sets number of times CartItemUseCase.ListCartItems should be invoked
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Times(n uint64) *mCartItemUseCaseMockListCartItems {
	if n == 0 {
		mmListCartItems.mock.t.Fatalf("Times of CartItemUseCaseMock.ListCartItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCartItems.expectedInvocations, n)
	mmListCartItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCartItems
}

func (mmListCartItems *mCartItemUseCaseMockListCartItems) invocationsDone() bool {
	if len(mmListCartItems.expectations) == 0 && mmListCartItems.defaultExpectation == nil && mmListCartItems.mock.funcListCartItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCartItems.mock.afterListCartItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCartItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCartItems implements mm_usecase.CartItemUseCase
func (mmListCartItems *CartItemUseCaseMock) ListCartItems(ctx context.Context, userID domain.UserID) (l1 domain.ListCartItems, err error) {
	mm_atomic.AddUint64(&mmListCartItems.beforeListCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmListCartItems.afterListCartItemsCounter, 1)

	mmListCartItems.t.Helper()

	if mmListCartItems.inspectFuncListCartItems != nil {
		mmListCartItems.inspectFuncListCartItems(ctx, userID)
	}

	mm_params := CartItemUseCaseMockListCartItemsParams{ctx, userID}

	// Record call args
	mmListCartItems.ListCartItemsMock.mutex.Lock()
	mmListCartItems.ListCartItemsMock.callArgs = append(mmListCartItems.ListCartItemsMock.callArgs, &mm_params)
	mmListCartItems.ListCartItemsMock.mutex.Unlock()

	for _, e := range mmListCartItems.ListCartItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmListCartItems.ListCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCartItems.ListCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmListCartItems.ListCartItemsMock.defaultExpectation.params
		mm_want_ptrs := mmListCartItems.ListCartItemsMock.defaultExpectation.paramPtrs

		mm_got := CartItemUseCaseMockListCartItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCartItems.t.Errorf("CartItemUseCaseMock.ListCartItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCartItems.ListCartItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListCartItems.t.Errorf("CartItemUseCaseMock.ListCartItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCartItems.ListCartItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCartItems.t.Errorf("CartItemUseCaseMock.ListCartItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCartItems.ListCartItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCartItems.ListCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmListCartItems.t.Fatal("No results are set for the CartItemUseCaseMock.ListCartItems")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmListCartItems.funcListCartItems != nil {
		return mmListCartItems.funcListCartItems(ctx, userID)
	}
	mmListCartItems.t.Fatalf("Unexpected call to CartItemUseCaseMock.ListCartItems. %v %v", ctx, userID)
	return
}

// ListCartItemsAfterCounter returns a count of finished CartItemUseCaseMock.ListCartItems invocations
func (mmListCartItems *CartItemUseCaseMock) ListCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCartItems.afterListCartItemsCounter)
}

// ListCartItemsBeforeCounter returns a count of CartItemUseCaseMock.ListCartItems invocations
func (mmListCartItems *CartItemUseCaseMock) ListCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCartItems.beforeListCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CartItemUseCaseMock.ListCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCartItems *mCartItemUseCaseMockListCartItems) Calls() []*CartItemUseCaseMockListCartItemsParams {
	mmListCartItems.mutex.RLock()

	argCopy := make([]*CartItemUseCaseMockListCartItemsParams, len(mmListCartItems.callArgs))
	copy(argCopy, mmListCartItems.callArgs)

	mmListCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockListCartItemsDone returns true if the count of the ListCartItems invocations corresponds
// the number of defined expectations
func (m *CartItemUseCaseMock) MinimockListCartItemsDone() bool {
	if m.ListCartItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCartItemsMock.invocationsDone()
}

// MinimockListCartItemsInspect logs each unmet expectation
func (m *CartItemUseCaseMock) MinimockListCartItemsInspect() {
	for _, e := range m.ListCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ListCartItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCartItemsCounter := mm_atomic.LoadUint64(&m.afterListCartItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartItemsMock.defaultExpectation != nil && afterListCartItemsCounter < 1 {
		if m.ListCartItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ListCartItems at\n%s", m.ListCartItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemUseCaseMock.ListCartItems at\n%s with params: %#v", m.ListCartItemsMock.defaultExpectation.expectationOrigins.origin, *m.ListCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCartItems != nil && afterListCartItemsCounter < 1 {
		m.t.Errorf("Expected call to CartItemUseCaseMock.ListCartItems at\n%s", m.funcListCartItemsOrigin)
	}

	if !m.ListCartItemsMock.invocationsDone() && afterListCartItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemUseCaseMock.ListCartItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCartItemsMock.expectedInvocations), m.ListCartItemsMock.expectedInvocationsOrigin, afterListCartItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartItemUseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCartItemInspect()

			m.MinimockClearCartItemsInspect()

			m.MinimockDeleteCartItemInspect()

			m.MinimockListCartItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartItemUseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartItemUseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCartItemDone() &&
		m.MinimockClearCartItemsDone() &&
		m.MinimockDeleteCartItemDone() &&
		m.MinimockListCartItemsDone()
}
