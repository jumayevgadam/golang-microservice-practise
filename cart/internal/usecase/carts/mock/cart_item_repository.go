// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"cart/internal/domain"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartItemRepositoryMock implements mm_carts.CartItemRepository
type CartItemRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCartItemByUserID          func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (c2 domain.CartItem, err error)
	funcGetCartItemByUserIDOrigin    string
	inspectFuncGetCartItemByUserID   func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)
	afterGetCartItemByUserIDCounter  uint64
	beforeGetCartItemByUserIDCounter uint64
	GetCartItemByUserIDMock          mCartItemRepositoryMockGetCartItemByUserID

	funcListCartItemsByUserID          func(ctx context.Context, userID domain.UserID) (ca1 []domain.CartItem, err error)
	funcListCartItemsByUserIDOrigin    string
	inspectFuncListCartItemsByUserID   func(ctx context.Context, userID domain.UserID)
	afterListCartItemsByUserIDCounter  uint64
	beforeListCartItemsByUserIDCounter uint64
	ListCartItemsByUserIDMock          mCartItemRepositoryMockListCartItemsByUserID

	funcRemoveAllCartItems          func(ctx context.Context, userID domain.UserID) (err error)
	funcRemoveAllCartItemsOrigin    string
	inspectFuncRemoveAllCartItems   func(ctx context.Context, userID domain.UserID)
	afterRemoveAllCartItemsCounter  uint64
	beforeRemoveAllCartItemsCounter uint64
	RemoveAllCartItemsMock          mCartItemRepositoryMockRemoveAllCartItems

	funcRemoveCartItem          func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error)
	funcRemoveCartItemOrigin    string
	inspectFuncRemoveCartItem   func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)
	afterRemoveCartItemCounter  uint64
	beforeRemoveCartItemCounter uint64
	RemoveCartItemMock          mCartItemRepositoryMockRemoveCartItem

	funcSaveOrUpdateCartItem          func(ctx context.Context, cartItem domain.CartItem) (err error)
	funcSaveOrUpdateCartItemOrigin    string
	inspectFuncSaveOrUpdateCartItem   func(ctx context.Context, cartItem domain.CartItem)
	afterSaveOrUpdateCartItemCounter  uint64
	beforeSaveOrUpdateCartItemCounter uint64
	SaveOrUpdateCartItemMock          mCartItemRepositoryMockSaveOrUpdateCartItem
}

// NewCartItemRepositoryMock returns a mock for mm_carts.CartItemRepository
func NewCartItemRepositoryMock(t minimock.Tester) *CartItemRepositoryMock {
	m := &CartItemRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCartItemByUserIDMock = mCartItemRepositoryMockGetCartItemByUserID{mock: m}
	m.GetCartItemByUserIDMock.callArgs = []*CartItemRepositoryMockGetCartItemByUserIDParams{}

	m.ListCartItemsByUserIDMock = mCartItemRepositoryMockListCartItemsByUserID{mock: m}
	m.ListCartItemsByUserIDMock.callArgs = []*CartItemRepositoryMockListCartItemsByUserIDParams{}

	m.RemoveAllCartItemsMock = mCartItemRepositoryMockRemoveAllCartItems{mock: m}
	m.RemoveAllCartItemsMock.callArgs = []*CartItemRepositoryMockRemoveAllCartItemsParams{}

	m.RemoveCartItemMock = mCartItemRepositoryMockRemoveCartItem{mock: m}
	m.RemoveCartItemMock.callArgs = []*CartItemRepositoryMockRemoveCartItemParams{}

	m.SaveOrUpdateCartItemMock = mCartItemRepositoryMockSaveOrUpdateCartItem{mock: m}
	m.SaveOrUpdateCartItemMock.callArgs = []*CartItemRepositoryMockSaveOrUpdateCartItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartItemRepositoryMockGetCartItemByUserID struct {
	optional           bool
	mock               *CartItemRepositoryMock
	defaultExpectation *CartItemRepositoryMockGetCartItemByUserIDExpectation
	expectations       []*CartItemRepositoryMockGetCartItemByUserIDExpectation

	callArgs []*CartItemRepositoryMockGetCartItemByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemRepositoryMockGetCartItemByUserIDExpectation specifies expectation struct of the CartItemRepository.GetCartItemByUserID
type CartItemRepositoryMockGetCartItemByUserIDExpectation struct {
	mock               *CartItemRepositoryMock
	params             *CartItemRepositoryMockGetCartItemByUserIDParams
	paramPtrs          *CartItemRepositoryMockGetCartItemByUserIDParamPtrs
	expectationOrigins CartItemRepositoryMockGetCartItemByUserIDExpectationOrigins
	results            *CartItemRepositoryMockGetCartItemByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// CartItemRepositoryMockGetCartItemByUserIDParams contains parameters of the CartItemRepository.GetCartItemByUserID
type CartItemRepositoryMockGetCartItemByUserIDParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SkuID
}

// CartItemRepositoryMockGetCartItemByUserIDParamPtrs contains pointers to parameters of the CartItemRepository.GetCartItemByUserID
type CartItemRepositoryMockGetCartItemByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SkuID
}

// CartItemRepositoryMockGetCartItemByUserIDResults contains results of the CartItemRepository.GetCartItemByUserID
type CartItemRepositoryMockGetCartItemByUserIDResults struct {
	c2  domain.CartItem
	err error
}

// CartItemRepositoryMockGetCartItemByUserIDOrigins contains origins of expectations of the CartItemRepository.GetCartItemByUserID
type CartItemRepositoryMockGetCartItemByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Optional() *mCartItemRepositoryMockGetCartItemByUserID {
	mmGetCartItemByUserID.optional = true
	return mmGetCartItemByUserID
}

// Expect sets up expected params for CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Expect(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *mCartItemRepositoryMockGetCartItemByUserID {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	if mmGetCartItemByUserID.defaultExpectation == nil {
		mmGetCartItemByUserID.defaultExpectation = &CartItemRepositoryMockGetCartItemByUserIDExpectation{}
	}

	if mmGetCartItemByUserID.defaultExpectation.paramPtrs != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by ExpectParams functions")
	}

	mmGetCartItemByUserID.defaultExpectation.params = &CartItemRepositoryMockGetCartItemByUserIDParams{ctx, userID, skuID}
	mmGetCartItemByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartItemByUserID.expectations {
		if minimock.Equal(e.params, mmGetCartItemByUserID.defaultExpectation.params) {
			mmGetCartItemByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItemByUserID.defaultExpectation.params)
		}
	}

	return mmGetCartItemByUserID
}

// ExpectCtxParam1 sets up expected param ctx for CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) ExpectCtxParam1(ctx context.Context) *mCartItemRepositoryMockGetCartItemByUserID {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	if mmGetCartItemByUserID.defaultExpectation == nil {
		mmGetCartItemByUserID.defaultExpectation = &CartItemRepositoryMockGetCartItemByUserIDExpectation{}
	}

	if mmGetCartItemByUserID.defaultExpectation.params != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Expect")
	}

	if mmGetCartItemByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartItemByUserID.defaultExpectation.paramPtrs = &CartItemRepositoryMockGetCartItemByUserIDParamPtrs{}
	}
	mmGetCartItemByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartItemByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartItemByUserID
}

// ExpectUserIDParam2 sets up expected param userID for CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) ExpectUserIDParam2(userID domain.UserID) *mCartItemRepositoryMockGetCartItemByUserID {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	if mmGetCartItemByUserID.defaultExpectation == nil {
		mmGetCartItemByUserID.defaultExpectation = &CartItemRepositoryMockGetCartItemByUserIDExpectation{}
	}

	if mmGetCartItemByUserID.defaultExpectation.params != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Expect")
	}

	if mmGetCartItemByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartItemByUserID.defaultExpectation.paramPtrs = &CartItemRepositoryMockGetCartItemByUserIDParamPtrs{}
	}
	mmGetCartItemByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmGetCartItemByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCartItemByUserID
}

// ExpectSkuIDParam3 sets up expected param skuID for CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) ExpectSkuIDParam3(skuID domain.SkuID) *mCartItemRepositoryMockGetCartItemByUserID {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	if mmGetCartItemByUserID.defaultExpectation == nil {
		mmGetCartItemByUserID.defaultExpectation = &CartItemRepositoryMockGetCartItemByUserIDExpectation{}
	}

	if mmGetCartItemByUserID.defaultExpectation.params != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Expect")
	}

	if mmGetCartItemByUserID.defaultExpectation.paramPtrs == nil {
		mmGetCartItemByUserID.defaultExpectation.paramPtrs = &CartItemRepositoryMockGetCartItemByUserIDParamPtrs{}
	}
	mmGetCartItemByUserID.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetCartItemByUserID.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetCartItemByUserID
}

// Inspect accepts an inspector function that has same arguments as the CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)) *mCartItemRepositoryMockGetCartItemByUserID {
	if mmGetCartItemByUserID.mock.inspectFuncGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("Inspect function is already set for CartItemRepositoryMock.GetCartItemByUserID")
	}

	mmGetCartItemByUserID.mock.inspectFuncGetCartItemByUserID = f

	return mmGetCartItemByUserID
}

// Return sets up results that will be returned by CartItemRepository.GetCartItemByUserID
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Return(c2 domain.CartItem, err error) *CartItemRepositoryMock {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	if mmGetCartItemByUserID.defaultExpectation == nil {
		mmGetCartItemByUserID.defaultExpectation = &CartItemRepositoryMockGetCartItemByUserIDExpectation{mock: mmGetCartItemByUserID.mock}
	}
	mmGetCartItemByUserID.defaultExpectation.results = &CartItemRepositoryMockGetCartItemByUserIDResults{c2, err}
	mmGetCartItemByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartItemByUserID.mock
}

// Set uses given function f to mock the CartItemRepository.GetCartItemByUserID method
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (c2 domain.CartItem, err error)) *CartItemRepositoryMock {
	if mmGetCartItemByUserID.defaultExpectation != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("Default expectation is already set for the CartItemRepository.GetCartItemByUserID method")
	}

	if len(mmGetCartItemByUserID.expectations) > 0 {
		mmGetCartItemByUserID.mock.t.Fatalf("Some expectations are already set for the CartItemRepository.GetCartItemByUserID method")
	}

	mmGetCartItemByUserID.mock.funcGetCartItemByUserID = f
	mmGetCartItemByUserID.mock.funcGetCartItemByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetCartItemByUserID.mock
}

// When sets expectation for the CartItemRepository.GetCartItemByUserID which will trigger the result defined by the following
// Then helper
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) When(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *CartItemRepositoryMockGetCartItemByUserIDExpectation {
	if mmGetCartItemByUserID.mock.funcGetCartItemByUserID != nil {
		mmGetCartItemByUserID.mock.t.Fatalf("CartItemRepositoryMock.GetCartItemByUserID mock is already set by Set")
	}

	expectation := &CartItemRepositoryMockGetCartItemByUserIDExpectation{
		mock:               mmGetCartItemByUserID.mock,
		params:             &CartItemRepositoryMockGetCartItemByUserIDParams{ctx, userID, skuID},
		expectationOrigins: CartItemRepositoryMockGetCartItemByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartItemByUserID.expectations = append(mmGetCartItemByUserID.expectations, expectation)
	return expectation
}

// Then sets up CartItemRepository.GetCartItemByUserID return parameters for the expectation previously defined by the When method
func (e *CartItemRepositoryMockGetCartItemByUserIDExpectation) Then(c2 domain.CartItem, err error) *CartItemRepositoryMock {
	e.results = &CartItemRepositoryMockGetCartItemByUserIDResults{c2, err}
	return e.mock
}

// Times sets number of times CartItemRepository.GetCartItemByUserID should be invoked
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Times(n uint64) *mCartItemRepositoryMockGetCartItemByUserID {
	if n == 0 {
		mmGetCartItemByUserID.mock.t.Fatalf("Times of CartItemRepositoryMock.GetCartItemByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartItemByUserID.expectedInvocations, n)
	mmGetCartItemByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartItemByUserID
}

func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) invocationsDone() bool {
	if len(mmGetCartItemByUserID.expectations) == 0 && mmGetCartItemByUserID.defaultExpectation == nil && mmGetCartItemByUserID.mock.funcGetCartItemByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartItemByUserID.mock.afterGetCartItemByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartItemByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartItemByUserID implements mm_carts.CartItemRepository
func (mmGetCartItemByUserID *CartItemRepositoryMock) GetCartItemByUserID(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (c2 domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItemByUserID.beforeGetCartItemByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItemByUserID.afterGetCartItemByUserIDCounter, 1)

	mmGetCartItemByUserID.t.Helper()

	if mmGetCartItemByUserID.inspectFuncGetCartItemByUserID != nil {
		mmGetCartItemByUserID.inspectFuncGetCartItemByUserID(ctx, userID, skuID)
	}

	mm_params := CartItemRepositoryMockGetCartItemByUserIDParams{ctx, userID, skuID}

	// Record call args
	mmGetCartItemByUserID.GetCartItemByUserIDMock.mutex.Lock()
	mmGetCartItemByUserID.GetCartItemByUserIDMock.callArgs = append(mmGetCartItemByUserID.GetCartItemByUserIDMock.callArgs, &mm_params)
	mmGetCartItemByUserID.GetCartItemByUserIDMock.mutex.Unlock()

	for _, e := range mmGetCartItemByUserID.GetCartItemByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CartItemRepositoryMockGetCartItemByUserIDParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartItemByUserID.t.Errorf("CartItemRepositoryMock.GetCartItemByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCartItemByUserID.t.Errorf("CartItemRepositoryMock.GetCartItemByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetCartItemByUserID.t.Errorf("CartItemRepositoryMock.GetCartItemByUserID got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItemByUserID.t.Errorf("CartItemRepositoryMock.GetCartItemByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItemByUserID.GetCartItemByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItemByUserID.t.Fatal("No results are set for the CartItemRepositoryMock.GetCartItemByUserID")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartItemByUserID.funcGetCartItemByUserID != nil {
		return mmGetCartItemByUserID.funcGetCartItemByUserID(ctx, userID, skuID)
	}
	mmGetCartItemByUserID.t.Fatalf("Unexpected call to CartItemRepositoryMock.GetCartItemByUserID. %v %v %v", ctx, userID, skuID)
	return
}

// GetCartItemByUserIDAfterCounter returns a count of finished CartItemRepositoryMock.GetCartItemByUserID invocations
func (mmGetCartItemByUserID *CartItemRepositoryMock) GetCartItemByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemByUserID.afterGetCartItemByUserIDCounter)
}

// GetCartItemByUserIDBeforeCounter returns a count of CartItemRepositoryMock.GetCartItemByUserID invocations
func (mmGetCartItemByUserID *CartItemRepositoryMock) GetCartItemByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItemByUserID.beforeGetCartItemByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CartItemRepositoryMock.GetCartItemByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItemByUserID *mCartItemRepositoryMockGetCartItemByUserID) Calls() []*CartItemRepositoryMockGetCartItemByUserIDParams {
	mmGetCartItemByUserID.mutex.RLock()

	argCopy := make([]*CartItemRepositoryMockGetCartItemByUserIDParams, len(mmGetCartItemByUserID.callArgs))
	copy(argCopy, mmGetCartItemByUserID.callArgs)

	mmGetCartItemByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemByUserIDDone returns true if the count of the GetCartItemByUserID invocations corresponds
// the number of defined expectations
func (m *CartItemRepositoryMock) MinimockGetCartItemByUserIDDone() bool {
	if m.GetCartItemByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartItemByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartItemByUserIDMock.invocationsDone()
}

// MinimockGetCartItemByUserIDInspect logs each unmet expectation
func (m *CartItemRepositoryMock) MinimockGetCartItemByUserIDInspect() {
	for _, e := range m.GetCartItemByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemRepositoryMock.GetCartItemByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartItemByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetCartItemByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemByUserIDMock.defaultExpectation != nil && afterGetCartItemByUserIDCounter < 1 {
		if m.GetCartItemByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemRepositoryMock.GetCartItemByUserID at\n%s", m.GetCartItemByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemRepositoryMock.GetCartItemByUserID at\n%s with params: %#v", m.GetCartItemByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCartItemByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItemByUserID != nil && afterGetCartItemByUserIDCounter < 1 {
		m.t.Errorf("Expected call to CartItemRepositoryMock.GetCartItemByUserID at\n%s", m.funcGetCartItemByUserIDOrigin)
	}

	if !m.GetCartItemByUserIDMock.invocationsDone() && afterGetCartItemByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemRepositoryMock.GetCartItemByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartItemByUserIDMock.expectedInvocations), m.GetCartItemByUserIDMock.expectedInvocationsOrigin, afterGetCartItemByUserIDCounter)
	}
}

type mCartItemRepositoryMockListCartItemsByUserID struct {
	optional           bool
	mock               *CartItemRepositoryMock
	defaultExpectation *CartItemRepositoryMockListCartItemsByUserIDExpectation
	expectations       []*CartItemRepositoryMockListCartItemsByUserIDExpectation

	callArgs []*CartItemRepositoryMockListCartItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemRepositoryMockListCartItemsByUserIDExpectation specifies expectation struct of the CartItemRepository.ListCartItemsByUserID
type CartItemRepositoryMockListCartItemsByUserIDExpectation struct {
	mock               *CartItemRepositoryMock
	params             *CartItemRepositoryMockListCartItemsByUserIDParams
	paramPtrs          *CartItemRepositoryMockListCartItemsByUserIDParamPtrs
	expectationOrigins CartItemRepositoryMockListCartItemsByUserIDExpectationOrigins
	results            *CartItemRepositoryMockListCartItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// CartItemRepositoryMockListCartItemsByUserIDParams contains parameters of the CartItemRepository.ListCartItemsByUserID
type CartItemRepositoryMockListCartItemsByUserIDParams struct {
	ctx    context.Context
	userID domain.UserID
}

// CartItemRepositoryMockListCartItemsByUserIDParamPtrs contains pointers to parameters of the CartItemRepository.ListCartItemsByUserID
type CartItemRepositoryMockListCartItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
}

// CartItemRepositoryMockListCartItemsByUserIDResults contains results of the CartItemRepository.ListCartItemsByUserID
type CartItemRepositoryMockListCartItemsByUserIDResults struct {
	ca1 []domain.CartItem
	err error
}

// CartItemRepositoryMockListCartItemsByUserIDOrigins contains origins of expectations of the CartItemRepository.ListCartItemsByUserID
type CartItemRepositoryMockListCartItemsByUserIDExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Optional() *mCartItemRepositoryMockListCartItemsByUserID {
	mmListCartItemsByUserID.optional = true
	return mmListCartItemsByUserID
}

// Expect sets up expected params for CartItemRepository.ListCartItemsByUserID
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Expect(ctx context.Context, userID domain.UserID) *mCartItemRepositoryMockListCartItemsByUserID {
	if mmListCartItemsByUserID.mock.funcListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Set")
	}

	if mmListCartItemsByUserID.defaultExpectation == nil {
		mmListCartItemsByUserID.defaultExpectation = &CartItemRepositoryMockListCartItemsByUserIDExpectation{}
	}

	if mmListCartItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by ExpectParams functions")
	}

	mmListCartItemsByUserID.defaultExpectation.params = &CartItemRepositoryMockListCartItemsByUserIDParams{ctx, userID}
	mmListCartItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCartItemsByUserID.expectations {
		if minimock.Equal(e.params, mmListCartItemsByUserID.defaultExpectation.params) {
			mmListCartItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCartItemsByUserID.defaultExpectation.params)
		}
	}

	return mmListCartItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for CartItemRepository.ListCartItemsByUserID
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) ExpectCtxParam1(ctx context.Context) *mCartItemRepositoryMockListCartItemsByUserID {
	if mmListCartItemsByUserID.mock.funcListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Set")
	}

	if mmListCartItemsByUserID.defaultExpectation == nil {
		mmListCartItemsByUserID.defaultExpectation = &CartItemRepositoryMockListCartItemsByUserIDExpectation{}
	}

	if mmListCartItemsByUserID.defaultExpectation.params != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Expect")
	}

	if mmListCartItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmListCartItemsByUserID.defaultExpectation.paramPtrs = &CartItemRepositoryMockListCartItemsByUserIDParamPtrs{}
	}
	mmListCartItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCartItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCartItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for CartItemRepository.ListCartItemsByUserID
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) ExpectUserIDParam2(userID domain.UserID) *mCartItemRepositoryMockListCartItemsByUserID {
	if mmListCartItemsByUserID.mock.funcListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Set")
	}

	if mmListCartItemsByUserID.defaultExpectation == nil {
		mmListCartItemsByUserID.defaultExpectation = &CartItemRepositoryMockListCartItemsByUserIDExpectation{}
	}

	if mmListCartItemsByUserID.defaultExpectation.params != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Expect")
	}

	if mmListCartItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmListCartItemsByUserID.defaultExpectation.paramPtrs = &CartItemRepositoryMockListCartItemsByUserIDParamPtrs{}
	}
	mmListCartItemsByUserID.defaultExpectation.paramPtrs.userID = &userID
	mmListCartItemsByUserID.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmListCartItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the CartItemRepository.ListCartItemsByUserID
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Inspect(f func(ctx context.Context, userID domain.UserID)) *mCartItemRepositoryMockListCartItemsByUserID {
	if mmListCartItemsByUserID.mock.inspectFuncListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("Inspect function is already set for CartItemRepositoryMock.ListCartItemsByUserID")
	}

	mmListCartItemsByUserID.mock.inspectFuncListCartItemsByUserID = f

	return mmListCartItemsByUserID
}

// Return sets up results that will be returned by CartItemRepository.ListCartItemsByUserID
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Return(ca1 []domain.CartItem, err error) *CartItemRepositoryMock {
	if mmListCartItemsByUserID.mock.funcListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Set")
	}

	if mmListCartItemsByUserID.defaultExpectation == nil {
		mmListCartItemsByUserID.defaultExpectation = &CartItemRepositoryMockListCartItemsByUserIDExpectation{mock: mmListCartItemsByUserID.mock}
	}
	mmListCartItemsByUserID.defaultExpectation.results = &CartItemRepositoryMockListCartItemsByUserIDResults{ca1, err}
	mmListCartItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCartItemsByUserID.mock
}

// Set uses given function f to mock the CartItemRepository.ListCartItemsByUserID method
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Set(f func(ctx context.Context, userID domain.UserID) (ca1 []domain.CartItem, err error)) *CartItemRepositoryMock {
	if mmListCartItemsByUserID.defaultExpectation != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("Default expectation is already set for the CartItemRepository.ListCartItemsByUserID method")
	}

	if len(mmListCartItemsByUserID.expectations) > 0 {
		mmListCartItemsByUserID.mock.t.Fatalf("Some expectations are already set for the CartItemRepository.ListCartItemsByUserID method")
	}

	mmListCartItemsByUserID.mock.funcListCartItemsByUserID = f
	mmListCartItemsByUserID.mock.funcListCartItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmListCartItemsByUserID.mock
}

// When sets expectation for the CartItemRepository.ListCartItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) When(ctx context.Context, userID domain.UserID) *CartItemRepositoryMockListCartItemsByUserIDExpectation {
	if mmListCartItemsByUserID.mock.funcListCartItemsByUserID != nil {
		mmListCartItemsByUserID.mock.t.Fatalf("CartItemRepositoryMock.ListCartItemsByUserID mock is already set by Set")
	}

	expectation := &CartItemRepositoryMockListCartItemsByUserIDExpectation{
		mock:               mmListCartItemsByUserID.mock,
		params:             &CartItemRepositoryMockListCartItemsByUserIDParams{ctx, userID},
		expectationOrigins: CartItemRepositoryMockListCartItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCartItemsByUserID.expectations = append(mmListCartItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up CartItemRepository.ListCartItemsByUserID return parameters for the expectation previously defined by the When method
func (e *CartItemRepositoryMockListCartItemsByUserIDExpectation) Then(ca1 []domain.CartItem, err error) *CartItemRepositoryMock {
	e.results = &CartItemRepositoryMockListCartItemsByUserIDResults{ca1, err}
	return e.mock
}

// Times sets number of times CartItemRepository.ListCartItemsByUserID should be invoked
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Times(n uint64) *mCartItemRepositoryMockListCartItemsByUserID {
	if n == 0 {
		mmListCartItemsByUserID.mock.t.Fatalf("Times of CartItemRepositoryMock.ListCartItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCartItemsByUserID.expectedInvocations, n)
	mmListCartItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCartItemsByUserID
}

func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) invocationsDone() bool {
	if len(mmListCartItemsByUserID.expectations) == 0 && mmListCartItemsByUserID.defaultExpectation == nil && mmListCartItemsByUserID.mock.funcListCartItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCartItemsByUserID.mock.afterListCartItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCartItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCartItemsByUserID implements mm_carts.CartItemRepository
func (mmListCartItemsByUserID *CartItemRepositoryMock) ListCartItemsByUserID(ctx context.Context, userID domain.UserID) (ca1 []domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmListCartItemsByUserID.beforeListCartItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmListCartItemsByUserID.afterListCartItemsByUserIDCounter, 1)

	mmListCartItemsByUserID.t.Helper()

	if mmListCartItemsByUserID.inspectFuncListCartItemsByUserID != nil {
		mmListCartItemsByUserID.inspectFuncListCartItemsByUserID(ctx, userID)
	}

	mm_params := CartItemRepositoryMockListCartItemsByUserIDParams{ctx, userID}

	// Record call args
	mmListCartItemsByUserID.ListCartItemsByUserIDMock.mutex.Lock()
	mmListCartItemsByUserID.ListCartItemsByUserIDMock.callArgs = append(mmListCartItemsByUserID.ListCartItemsByUserIDMock.callArgs, &mm_params)
	mmListCartItemsByUserID.ListCartItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmListCartItemsByUserID.ListCartItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := CartItemRepositoryMockListCartItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCartItemsByUserID.t.Errorf("CartItemRepositoryMock.ListCartItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmListCartItemsByUserID.t.Errorf("CartItemRepositoryMock.ListCartItemsByUserID got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCartItemsByUserID.t.Errorf("CartItemRepositoryMock.ListCartItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCartItemsByUserID.ListCartItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmListCartItemsByUserID.t.Fatal("No results are set for the CartItemRepositoryMock.ListCartItemsByUserID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCartItemsByUserID.funcListCartItemsByUserID != nil {
		return mmListCartItemsByUserID.funcListCartItemsByUserID(ctx, userID)
	}
	mmListCartItemsByUserID.t.Fatalf("Unexpected call to CartItemRepositoryMock.ListCartItemsByUserID. %v %v", ctx, userID)
	return
}

// ListCartItemsByUserIDAfterCounter returns a count of finished CartItemRepositoryMock.ListCartItemsByUserID invocations
func (mmListCartItemsByUserID *CartItemRepositoryMock) ListCartItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCartItemsByUserID.afterListCartItemsByUserIDCounter)
}

// ListCartItemsByUserIDBeforeCounter returns a count of CartItemRepositoryMock.ListCartItemsByUserID invocations
func (mmListCartItemsByUserID *CartItemRepositoryMock) ListCartItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCartItemsByUserID.beforeListCartItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to CartItemRepositoryMock.ListCartItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCartItemsByUserID *mCartItemRepositoryMockListCartItemsByUserID) Calls() []*CartItemRepositoryMockListCartItemsByUserIDParams {
	mmListCartItemsByUserID.mutex.RLock()

	argCopy := make([]*CartItemRepositoryMockListCartItemsByUserIDParams, len(mmListCartItemsByUserID.callArgs))
	copy(argCopy, mmListCartItemsByUserID.callArgs)

	mmListCartItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockListCartItemsByUserIDDone returns true if the count of the ListCartItemsByUserID invocations corresponds
// the number of defined expectations
func (m *CartItemRepositoryMock) MinimockListCartItemsByUserIDDone() bool {
	if m.ListCartItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCartItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCartItemsByUserIDMock.invocationsDone()
}

// MinimockListCartItemsByUserIDInspect logs each unmet expectation
func (m *CartItemRepositoryMock) MinimockListCartItemsByUserIDInspect() {
	for _, e := range m.ListCartItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemRepositoryMock.ListCartItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCartItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterListCartItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartItemsByUserIDMock.defaultExpectation != nil && afterListCartItemsByUserIDCounter < 1 {
		if m.ListCartItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemRepositoryMock.ListCartItemsByUserID at\n%s", m.ListCartItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemRepositoryMock.ListCartItemsByUserID at\n%s with params: %#v", m.ListCartItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.ListCartItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCartItemsByUserID != nil && afterListCartItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to CartItemRepositoryMock.ListCartItemsByUserID at\n%s", m.funcListCartItemsByUserIDOrigin)
	}

	if !m.ListCartItemsByUserIDMock.invocationsDone() && afterListCartItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemRepositoryMock.ListCartItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCartItemsByUserIDMock.expectedInvocations), m.ListCartItemsByUserIDMock.expectedInvocationsOrigin, afterListCartItemsByUserIDCounter)
	}
}

type mCartItemRepositoryMockRemoveAllCartItems struct {
	optional           bool
	mock               *CartItemRepositoryMock
	defaultExpectation *CartItemRepositoryMockRemoveAllCartItemsExpectation
	expectations       []*CartItemRepositoryMockRemoveAllCartItemsExpectation

	callArgs []*CartItemRepositoryMockRemoveAllCartItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemRepositoryMockRemoveAllCartItemsExpectation specifies expectation struct of the CartItemRepository.RemoveAllCartItems
type CartItemRepositoryMockRemoveAllCartItemsExpectation struct {
	mock               *CartItemRepositoryMock
	params             *CartItemRepositoryMockRemoveAllCartItemsParams
	paramPtrs          *CartItemRepositoryMockRemoveAllCartItemsParamPtrs
	expectationOrigins CartItemRepositoryMockRemoveAllCartItemsExpectationOrigins
	results            *CartItemRepositoryMockRemoveAllCartItemsResults
	returnOrigin       string
	Counter            uint64
}

// CartItemRepositoryMockRemoveAllCartItemsParams contains parameters of the CartItemRepository.RemoveAllCartItems
type CartItemRepositoryMockRemoveAllCartItemsParams struct {
	ctx    context.Context
	userID domain.UserID
}

// CartItemRepositoryMockRemoveAllCartItemsParamPtrs contains pointers to parameters of the CartItemRepository.RemoveAllCartItems
type CartItemRepositoryMockRemoveAllCartItemsParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
}

// CartItemRepositoryMockRemoveAllCartItemsResults contains results of the CartItemRepository.RemoveAllCartItems
type CartItemRepositoryMockRemoveAllCartItemsResults struct {
	err error
}

// CartItemRepositoryMockRemoveAllCartItemsOrigins contains origins of expectations of the CartItemRepository.RemoveAllCartItems
type CartItemRepositoryMockRemoveAllCartItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Optional() *mCartItemRepositoryMockRemoveAllCartItems {
	mmRemoveAllCartItems.optional = true
	return mmRemoveAllCartItems
}

// Expect sets up expected params for CartItemRepository.RemoveAllCartItems
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Expect(ctx context.Context, userID domain.UserID) *mCartItemRepositoryMockRemoveAllCartItems {
	if mmRemoveAllCartItems.mock.funcRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Set")
	}

	if mmRemoveAllCartItems.defaultExpectation == nil {
		mmRemoveAllCartItems.defaultExpectation = &CartItemRepositoryMockRemoveAllCartItemsExpectation{}
	}

	if mmRemoveAllCartItems.defaultExpectation.paramPtrs != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by ExpectParams functions")
	}

	mmRemoveAllCartItems.defaultExpectation.params = &CartItemRepositoryMockRemoveAllCartItemsParams{ctx, userID}
	mmRemoveAllCartItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveAllCartItems.expectations {
		if minimock.Equal(e.params, mmRemoveAllCartItems.defaultExpectation.params) {
			mmRemoveAllCartItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAllCartItems.defaultExpectation.params)
		}
	}

	return mmRemoveAllCartItems
}

// ExpectCtxParam1 sets up expected param ctx for CartItemRepository.RemoveAllCartItems
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) ExpectCtxParam1(ctx context.Context) *mCartItemRepositoryMockRemoveAllCartItems {
	if mmRemoveAllCartItems.mock.funcRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Set")
	}

	if mmRemoveAllCartItems.defaultExpectation == nil {
		mmRemoveAllCartItems.defaultExpectation = &CartItemRepositoryMockRemoveAllCartItemsExpectation{}
	}

	if mmRemoveAllCartItems.defaultExpectation.params != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Expect")
	}

	if mmRemoveAllCartItems.defaultExpectation.paramPtrs == nil {
		mmRemoveAllCartItems.defaultExpectation.paramPtrs = &CartItemRepositoryMockRemoveAllCartItemsParamPtrs{}
	}
	mmRemoveAllCartItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveAllCartItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveAllCartItems
}

// ExpectUserIDParam2 sets up expected param userID for CartItemRepository.RemoveAllCartItems
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) ExpectUserIDParam2(userID domain.UserID) *mCartItemRepositoryMockRemoveAllCartItems {
	if mmRemoveAllCartItems.mock.funcRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Set")
	}

	if mmRemoveAllCartItems.defaultExpectation == nil {
		mmRemoveAllCartItems.defaultExpectation = &CartItemRepositoryMockRemoveAllCartItemsExpectation{}
	}

	if mmRemoveAllCartItems.defaultExpectation.params != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Expect")
	}

	if mmRemoveAllCartItems.defaultExpectation.paramPtrs == nil {
		mmRemoveAllCartItems.defaultExpectation.paramPtrs = &CartItemRepositoryMockRemoveAllCartItemsParamPtrs{}
	}
	mmRemoveAllCartItems.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveAllCartItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveAllCartItems
}

// Inspect accepts an inspector function that has same arguments as the CartItemRepository.RemoveAllCartItems
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Inspect(f func(ctx context.Context, userID domain.UserID)) *mCartItemRepositoryMockRemoveAllCartItems {
	if mmRemoveAllCartItems.mock.inspectFuncRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("Inspect function is already set for CartItemRepositoryMock.RemoveAllCartItems")
	}

	mmRemoveAllCartItems.mock.inspectFuncRemoveAllCartItems = f

	return mmRemoveAllCartItems
}

// Return sets up results that will be returned by CartItemRepository.RemoveAllCartItems
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Return(err error) *CartItemRepositoryMock {
	if mmRemoveAllCartItems.mock.funcRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Set")
	}

	if mmRemoveAllCartItems.defaultExpectation == nil {
		mmRemoveAllCartItems.defaultExpectation = &CartItemRepositoryMockRemoveAllCartItemsExpectation{mock: mmRemoveAllCartItems.mock}
	}
	mmRemoveAllCartItems.defaultExpectation.results = &CartItemRepositoryMockRemoveAllCartItemsResults{err}
	mmRemoveAllCartItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveAllCartItems.mock
}

// Set uses given function f to mock the CartItemRepository.RemoveAllCartItems method
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Set(f func(ctx context.Context, userID domain.UserID) (err error)) *CartItemRepositoryMock {
	if mmRemoveAllCartItems.defaultExpectation != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("Default expectation is already set for the CartItemRepository.RemoveAllCartItems method")
	}

	if len(mmRemoveAllCartItems.expectations) > 0 {
		mmRemoveAllCartItems.mock.t.Fatalf("Some expectations are already set for the CartItemRepository.RemoveAllCartItems method")
	}

	mmRemoveAllCartItems.mock.funcRemoveAllCartItems = f
	mmRemoveAllCartItems.mock.funcRemoveAllCartItemsOrigin = minimock.CallerInfo(1)
	return mmRemoveAllCartItems.mock
}

// When sets expectation for the CartItemRepository.RemoveAllCartItems which will trigger the result defined by the following
// Then helper
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) When(ctx context.Context, userID domain.UserID) *CartItemRepositoryMockRemoveAllCartItemsExpectation {
	if mmRemoveAllCartItems.mock.funcRemoveAllCartItems != nil {
		mmRemoveAllCartItems.mock.t.Fatalf("CartItemRepositoryMock.RemoveAllCartItems mock is already set by Set")
	}

	expectation := &CartItemRepositoryMockRemoveAllCartItemsExpectation{
		mock:               mmRemoveAllCartItems.mock,
		params:             &CartItemRepositoryMockRemoveAllCartItemsParams{ctx, userID},
		expectationOrigins: CartItemRepositoryMockRemoveAllCartItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveAllCartItems.expectations = append(mmRemoveAllCartItems.expectations, expectation)
	return expectation
}

// Then sets up CartItemRepository.RemoveAllCartItems return parameters for the expectation previously defined by the When method
func (e *CartItemRepositoryMockRemoveAllCartItemsExpectation) Then(err error) *CartItemRepositoryMock {
	e.results = &CartItemRepositoryMockRemoveAllCartItemsResults{err}
	return e.mock
}

// Times sets number of times CartItemRepository.RemoveAllCartItems should be invoked
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Times(n uint64) *mCartItemRepositoryMockRemoveAllCartItems {
	if n == 0 {
		mmRemoveAllCartItems.mock.t.Fatalf("Times of CartItemRepositoryMock.RemoveAllCartItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveAllCartItems.expectedInvocations, n)
	mmRemoveAllCartItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveAllCartItems
}

func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) invocationsDone() bool {
	if len(mmRemoveAllCartItems.expectations) == 0 && mmRemoveAllCartItems.defaultExpectation == nil && mmRemoveAllCartItems.mock.funcRemoveAllCartItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveAllCartItems.mock.afterRemoveAllCartItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveAllCartItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveAllCartItems implements mm_carts.CartItemRepository
func (mmRemoveAllCartItems *CartItemRepositoryMock) RemoveAllCartItems(ctx context.Context, userID domain.UserID) (err error) {
	mm_atomic.AddUint64(&mmRemoveAllCartItems.beforeRemoveAllCartItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAllCartItems.afterRemoveAllCartItemsCounter, 1)

	mmRemoveAllCartItems.t.Helper()

	if mmRemoveAllCartItems.inspectFuncRemoveAllCartItems != nil {
		mmRemoveAllCartItems.inspectFuncRemoveAllCartItems(ctx, userID)
	}

	mm_params := CartItemRepositoryMockRemoveAllCartItemsParams{ctx, userID}

	// Record call args
	mmRemoveAllCartItems.RemoveAllCartItemsMock.mutex.Lock()
	mmRemoveAllCartItems.RemoveAllCartItemsMock.callArgs = append(mmRemoveAllCartItems.RemoveAllCartItemsMock.callArgs, &mm_params)
	mmRemoveAllCartItems.RemoveAllCartItemsMock.mutex.Unlock()

	for _, e := range mmRemoveAllCartItems.RemoveAllCartItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.paramPtrs

		mm_got := CartItemRepositoryMockRemoveAllCartItemsParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveAllCartItems.t.Errorf("CartItemRepositoryMock.RemoveAllCartItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveAllCartItems.t.Errorf("CartItemRepositoryMock.RemoveAllCartItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAllCartItems.t.Errorf("CartItemRepositoryMock.RemoveAllCartItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAllCartItems.RemoveAllCartItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAllCartItems.t.Fatal("No results are set for the CartItemRepositoryMock.RemoveAllCartItems")
		}
		return (*mm_results).err
	}
	if mmRemoveAllCartItems.funcRemoveAllCartItems != nil {
		return mmRemoveAllCartItems.funcRemoveAllCartItems(ctx, userID)
	}
	mmRemoveAllCartItems.t.Fatalf("Unexpected call to CartItemRepositoryMock.RemoveAllCartItems. %v %v", ctx, userID)
	return
}

// RemoveAllCartItemsAfterCounter returns a count of finished CartItemRepositoryMock.RemoveAllCartItems invocations
func (mmRemoveAllCartItems *CartItemRepositoryMock) RemoveAllCartItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAllCartItems.afterRemoveAllCartItemsCounter)
}

// RemoveAllCartItemsBeforeCounter returns a count of CartItemRepositoryMock.RemoveAllCartItems invocations
func (mmRemoveAllCartItems *CartItemRepositoryMock) RemoveAllCartItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAllCartItems.beforeRemoveAllCartItemsCounter)
}

// Calls returns a list of arguments used in each call to CartItemRepositoryMock.RemoveAllCartItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAllCartItems *mCartItemRepositoryMockRemoveAllCartItems) Calls() []*CartItemRepositoryMockRemoveAllCartItemsParams {
	mmRemoveAllCartItems.mutex.RLock()

	argCopy := make([]*CartItemRepositoryMockRemoveAllCartItemsParams, len(mmRemoveAllCartItems.callArgs))
	copy(argCopy, mmRemoveAllCartItems.callArgs)

	mmRemoveAllCartItems.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAllCartItemsDone returns true if the count of the RemoveAllCartItems invocations corresponds
// the number of defined expectations
func (m *CartItemRepositoryMock) MinimockRemoveAllCartItemsDone() bool {
	if m.RemoveAllCartItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveAllCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveAllCartItemsMock.invocationsDone()
}

// MinimockRemoveAllCartItemsInspect logs each unmet expectation
func (m *CartItemRepositoryMock) MinimockRemoveAllCartItemsInspect() {
	for _, e := range m.RemoveAllCartItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveAllCartItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveAllCartItemsCounter := mm_atomic.LoadUint64(&m.afterRemoveAllCartItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllCartItemsMock.defaultExpectation != nil && afterRemoveAllCartItemsCounter < 1 {
		if m.RemoveAllCartItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveAllCartItems at\n%s", m.RemoveAllCartItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveAllCartItems at\n%s with params: %#v", m.RemoveAllCartItemsMock.defaultExpectation.expectationOrigins.origin, *m.RemoveAllCartItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAllCartItems != nil && afterRemoveAllCartItemsCounter < 1 {
		m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveAllCartItems at\n%s", m.funcRemoveAllCartItemsOrigin)
	}

	if !m.RemoveAllCartItemsMock.invocationsDone() && afterRemoveAllCartItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemRepositoryMock.RemoveAllCartItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveAllCartItemsMock.expectedInvocations), m.RemoveAllCartItemsMock.expectedInvocationsOrigin, afterRemoveAllCartItemsCounter)
	}
}

type mCartItemRepositoryMockRemoveCartItem struct {
	optional           bool
	mock               *CartItemRepositoryMock
	defaultExpectation *CartItemRepositoryMockRemoveCartItemExpectation
	expectations       []*CartItemRepositoryMockRemoveCartItemExpectation

	callArgs []*CartItemRepositoryMockRemoveCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemRepositoryMockRemoveCartItemExpectation specifies expectation struct of the CartItemRepository.RemoveCartItem
type CartItemRepositoryMockRemoveCartItemExpectation struct {
	mock               *CartItemRepositoryMock
	params             *CartItemRepositoryMockRemoveCartItemParams
	paramPtrs          *CartItemRepositoryMockRemoveCartItemParamPtrs
	expectationOrigins CartItemRepositoryMockRemoveCartItemExpectationOrigins
	results            *CartItemRepositoryMockRemoveCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartItemRepositoryMockRemoveCartItemParams contains parameters of the CartItemRepository.RemoveCartItem
type CartItemRepositoryMockRemoveCartItemParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SkuID
}

// CartItemRepositoryMockRemoveCartItemParamPtrs contains pointers to parameters of the CartItemRepository.RemoveCartItem
type CartItemRepositoryMockRemoveCartItemParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SkuID
}

// CartItemRepositoryMockRemoveCartItemResults contains results of the CartItemRepository.RemoveCartItem
type CartItemRepositoryMockRemoveCartItemResults struct {
	err error
}

// CartItemRepositoryMockRemoveCartItemOrigins contains origins of expectations of the CartItemRepository.RemoveCartItem
type CartItemRepositoryMockRemoveCartItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Optional() *mCartItemRepositoryMockRemoveCartItem {
	mmRemoveCartItem.optional = true
	return mmRemoveCartItem
}

// Expect sets up expected params for CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Expect(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *mCartItemRepositoryMockRemoveCartItem {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	if mmRemoveCartItem.defaultExpectation == nil {
		mmRemoveCartItem.defaultExpectation = &CartItemRepositoryMockRemoveCartItemExpectation{}
	}

	if mmRemoveCartItem.defaultExpectation.paramPtrs != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by ExpectParams functions")
	}

	mmRemoveCartItem.defaultExpectation.params = &CartItemRepositoryMockRemoveCartItemParams{ctx, userID, skuID}
	mmRemoveCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveCartItem.expectations {
		if minimock.Equal(e.params, mmRemoveCartItem.defaultExpectation.params) {
			mmRemoveCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveCartItem.defaultExpectation.params)
		}
	}

	return mmRemoveCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) ExpectCtxParam1(ctx context.Context) *mCartItemRepositoryMockRemoveCartItem {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	if mmRemoveCartItem.defaultExpectation == nil {
		mmRemoveCartItem.defaultExpectation = &CartItemRepositoryMockRemoveCartItemExpectation{}
	}

	if mmRemoveCartItem.defaultExpectation.params != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Expect")
	}

	if mmRemoveCartItem.defaultExpectation.paramPtrs == nil {
		mmRemoveCartItem.defaultExpectation.paramPtrs = &CartItemRepositoryMockRemoveCartItemParamPtrs{}
	}
	mmRemoveCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveCartItem
}

// ExpectUserIDParam2 sets up expected param userID for CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) ExpectUserIDParam2(userID domain.UserID) *mCartItemRepositoryMockRemoveCartItem {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	if mmRemoveCartItem.defaultExpectation == nil {
		mmRemoveCartItem.defaultExpectation = &CartItemRepositoryMockRemoveCartItemExpectation{}
	}

	if mmRemoveCartItem.defaultExpectation.params != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Expect")
	}

	if mmRemoveCartItem.defaultExpectation.paramPtrs == nil {
		mmRemoveCartItem.defaultExpectation.paramPtrs = &CartItemRepositoryMockRemoveCartItemParamPtrs{}
	}
	mmRemoveCartItem.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveCartItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveCartItem
}

// ExpectSkuIDParam3 sets up expected param skuID for CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) ExpectSkuIDParam3(skuID domain.SkuID) *mCartItemRepositoryMockRemoveCartItem {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	if mmRemoveCartItem.defaultExpectation == nil {
		mmRemoveCartItem.defaultExpectation = &CartItemRepositoryMockRemoveCartItemExpectation{}
	}

	if mmRemoveCartItem.defaultExpectation.params != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Expect")
	}

	if mmRemoveCartItem.defaultExpectation.paramPtrs == nil {
		mmRemoveCartItem.defaultExpectation.paramPtrs = &CartItemRepositoryMockRemoveCartItemParamPtrs{}
	}
	mmRemoveCartItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmRemoveCartItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmRemoveCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID)) *mCartItemRepositoryMockRemoveCartItem {
	if mmRemoveCartItem.mock.inspectFuncRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("Inspect function is already set for CartItemRepositoryMock.RemoveCartItem")
	}

	mmRemoveCartItem.mock.inspectFuncRemoveCartItem = f

	return mmRemoveCartItem
}

// Return sets up results that will be returned by CartItemRepository.RemoveCartItem
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Return(err error) *CartItemRepositoryMock {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	if mmRemoveCartItem.defaultExpectation == nil {
		mmRemoveCartItem.defaultExpectation = &CartItemRepositoryMockRemoveCartItemExpectation{mock: mmRemoveCartItem.mock}
	}
	mmRemoveCartItem.defaultExpectation.results = &CartItemRepositoryMockRemoveCartItemResults{err}
	mmRemoveCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveCartItem.mock
}

// Set uses given function f to mock the CartItemRepository.RemoveCartItem method
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error)) *CartItemRepositoryMock {
	if mmRemoveCartItem.defaultExpectation != nil {
		mmRemoveCartItem.mock.t.Fatalf("Default expectation is already set for the CartItemRepository.RemoveCartItem method")
	}

	if len(mmRemoveCartItem.expectations) > 0 {
		mmRemoveCartItem.mock.t.Fatalf("Some expectations are already set for the CartItemRepository.RemoveCartItem method")
	}

	mmRemoveCartItem.mock.funcRemoveCartItem = f
	mmRemoveCartItem.mock.funcRemoveCartItemOrigin = minimock.CallerInfo(1)
	return mmRemoveCartItem.mock
}

// When sets expectation for the CartItemRepository.RemoveCartItem which will trigger the result defined by the following
// Then helper
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) When(ctx context.Context, userID domain.UserID, skuID domain.SkuID) *CartItemRepositoryMockRemoveCartItemExpectation {
	if mmRemoveCartItem.mock.funcRemoveCartItem != nil {
		mmRemoveCartItem.mock.t.Fatalf("CartItemRepositoryMock.RemoveCartItem mock is already set by Set")
	}

	expectation := &CartItemRepositoryMockRemoveCartItemExpectation{
		mock:               mmRemoveCartItem.mock,
		params:             &CartItemRepositoryMockRemoveCartItemParams{ctx, userID, skuID},
		expectationOrigins: CartItemRepositoryMockRemoveCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveCartItem.expectations = append(mmRemoveCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartItemRepository.RemoveCartItem return parameters for the expectation previously defined by the When method
func (e *CartItemRepositoryMockRemoveCartItemExpectation) Then(err error) *CartItemRepositoryMock {
	e.results = &CartItemRepositoryMockRemoveCartItemResults{err}
	return e.mock
}

// Times sets number of times CartItemRepository.RemoveCartItem should be invoked
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Times(n uint64) *mCartItemRepositoryMockRemoveCartItem {
	if n == 0 {
		mmRemoveCartItem.mock.t.Fatalf("Times of CartItemRepositoryMock.RemoveCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveCartItem.expectedInvocations, n)
	mmRemoveCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveCartItem
}

func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) invocationsDone() bool {
	if len(mmRemoveCartItem.expectations) == 0 && mmRemoveCartItem.defaultExpectation == nil && mmRemoveCartItem.mock.funcRemoveCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveCartItem.mock.afterRemoveCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveCartItem implements mm_carts.CartItemRepository
func (mmRemoveCartItem *CartItemRepositoryMock) RemoveCartItem(ctx context.Context, userID domain.UserID, skuID domain.SkuID) (err error) {
	mm_atomic.AddUint64(&mmRemoveCartItem.beforeRemoveCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveCartItem.afterRemoveCartItemCounter, 1)

	mmRemoveCartItem.t.Helper()

	if mmRemoveCartItem.inspectFuncRemoveCartItem != nil {
		mmRemoveCartItem.inspectFuncRemoveCartItem(ctx, userID, skuID)
	}

	mm_params := CartItemRepositoryMockRemoveCartItemParams{ctx, userID, skuID}

	// Record call args
	mmRemoveCartItem.RemoveCartItemMock.mutex.Lock()
	mmRemoveCartItem.RemoveCartItemMock.callArgs = append(mmRemoveCartItem.RemoveCartItemMock.callArgs, &mm_params)
	mmRemoveCartItem.RemoveCartItemMock.mutex.Unlock()

	for _, e := range mmRemoveCartItem.RemoveCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveCartItem.RemoveCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartItemRepositoryMockRemoveCartItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveCartItem.t.Errorf("CartItemRepositoryMock.RemoveCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveCartItem.t.Errorf("CartItemRepositoryMock.RemoveCartItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmRemoveCartItem.t.Errorf("CartItemRepositoryMock.RemoveCartItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveCartItem.t.Errorf("CartItemRepositoryMock.RemoveCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveCartItem.RemoveCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveCartItem.t.Fatal("No results are set for the CartItemRepositoryMock.RemoveCartItem")
		}
		return (*mm_results).err
	}
	if mmRemoveCartItem.funcRemoveCartItem != nil {
		return mmRemoveCartItem.funcRemoveCartItem(ctx, userID, skuID)
	}
	mmRemoveCartItem.t.Fatalf("Unexpected call to CartItemRepositoryMock.RemoveCartItem. %v %v %v", ctx, userID, skuID)
	return
}

// RemoveCartItemAfterCounter returns a count of finished CartItemRepositoryMock.RemoveCartItem invocations
func (mmRemoveCartItem *CartItemRepositoryMock) RemoveCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCartItem.afterRemoveCartItemCounter)
}

// RemoveCartItemBeforeCounter returns a count of CartItemRepositoryMock.RemoveCartItem invocations
func (mmRemoveCartItem *CartItemRepositoryMock) RemoveCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCartItem.beforeRemoveCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartItemRepositoryMock.RemoveCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveCartItem *mCartItemRepositoryMockRemoveCartItem) Calls() []*CartItemRepositoryMockRemoveCartItemParams {
	mmRemoveCartItem.mutex.RLock()

	argCopy := make([]*CartItemRepositoryMockRemoveCartItemParams, len(mmRemoveCartItem.callArgs))
	copy(argCopy, mmRemoveCartItem.callArgs)

	mmRemoveCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveCartItemDone returns true if the count of the RemoveCartItem invocations corresponds
// the number of defined expectations
func (m *CartItemRepositoryMock) MinimockRemoveCartItemDone() bool {
	if m.RemoveCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveCartItemMock.invocationsDone()
}

// MinimockRemoveCartItemInspect logs each unmet expectation
func (m *CartItemRepositoryMock) MinimockRemoveCartItemInspect() {
	for _, e := range m.RemoveCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCartItemCounter := mm_atomic.LoadUint64(&m.afterRemoveCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveCartItemMock.defaultExpectation != nil && afterRemoveCartItemCounter < 1 {
		if m.RemoveCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveCartItem at\n%s", m.RemoveCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveCartItem at\n%s with params: %#v", m.RemoveCartItemMock.defaultExpectation.expectationOrigins.origin, *m.RemoveCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveCartItem != nil && afterRemoveCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartItemRepositoryMock.RemoveCartItem at\n%s", m.funcRemoveCartItemOrigin)
	}

	if !m.RemoveCartItemMock.invocationsDone() && afterRemoveCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemRepositoryMock.RemoveCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveCartItemMock.expectedInvocations), m.RemoveCartItemMock.expectedInvocationsOrigin, afterRemoveCartItemCounter)
	}
}

type mCartItemRepositoryMockSaveOrUpdateCartItem struct {
	optional           bool
	mock               *CartItemRepositoryMock
	defaultExpectation *CartItemRepositoryMockSaveOrUpdateCartItemExpectation
	expectations       []*CartItemRepositoryMockSaveOrUpdateCartItemExpectation

	callArgs []*CartItemRepositoryMockSaveOrUpdateCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartItemRepositoryMockSaveOrUpdateCartItemExpectation specifies expectation struct of the CartItemRepository.SaveOrUpdateCartItem
type CartItemRepositoryMockSaveOrUpdateCartItemExpectation struct {
	mock               *CartItemRepositoryMock
	params             *CartItemRepositoryMockSaveOrUpdateCartItemParams
	paramPtrs          *CartItemRepositoryMockSaveOrUpdateCartItemParamPtrs
	expectationOrigins CartItemRepositoryMockSaveOrUpdateCartItemExpectationOrigins
	results            *CartItemRepositoryMockSaveOrUpdateCartItemResults
	returnOrigin       string
	Counter            uint64
}

// CartItemRepositoryMockSaveOrUpdateCartItemParams contains parameters of the CartItemRepository.SaveOrUpdateCartItem
type CartItemRepositoryMockSaveOrUpdateCartItemParams struct {
	ctx      context.Context
	cartItem domain.CartItem
}

// CartItemRepositoryMockSaveOrUpdateCartItemParamPtrs contains pointers to parameters of the CartItemRepository.SaveOrUpdateCartItem
type CartItemRepositoryMockSaveOrUpdateCartItemParamPtrs struct {
	ctx      *context.Context
	cartItem *domain.CartItem
}

// CartItemRepositoryMockSaveOrUpdateCartItemResults contains results of the CartItemRepository.SaveOrUpdateCartItem
type CartItemRepositoryMockSaveOrUpdateCartItemResults struct {
	err error
}

// CartItemRepositoryMockSaveOrUpdateCartItemOrigins contains origins of expectations of the CartItemRepository.SaveOrUpdateCartItem
type CartItemRepositoryMockSaveOrUpdateCartItemExpectationOrigins struct {
	origin         string
	originCtx      string
	originCartItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Optional() *mCartItemRepositoryMockSaveOrUpdateCartItem {
	mmSaveOrUpdateCartItem.optional = true
	return mmSaveOrUpdateCartItem
}

// Expect sets up expected params for CartItemRepository.SaveOrUpdateCartItem
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Expect(ctx context.Context, cartItem domain.CartItem) *mCartItemRepositoryMockSaveOrUpdateCartItem {
	if mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Set")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation == nil {
		mmSaveOrUpdateCartItem.defaultExpectation = &CartItemRepositoryMockSaveOrUpdateCartItemExpectation{}
	}

	if mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by ExpectParams functions")
	}

	mmSaveOrUpdateCartItem.defaultExpectation.params = &CartItemRepositoryMockSaveOrUpdateCartItemParams{ctx, cartItem}
	mmSaveOrUpdateCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveOrUpdateCartItem.expectations {
		if minimock.Equal(e.params, mmSaveOrUpdateCartItem.defaultExpectation.params) {
			mmSaveOrUpdateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrUpdateCartItem.defaultExpectation.params)
		}
	}

	return mmSaveOrUpdateCartItem
}

// ExpectCtxParam1 sets up expected param ctx for CartItemRepository.SaveOrUpdateCartItem
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) ExpectCtxParam1(ctx context.Context) *mCartItemRepositoryMockSaveOrUpdateCartItem {
	if mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Set")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation == nil {
		mmSaveOrUpdateCartItem.defaultExpectation = &CartItemRepositoryMockSaveOrUpdateCartItemExpectation{}
	}

	if mmSaveOrUpdateCartItem.defaultExpectation.params != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Expect")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs == nil {
		mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs = &CartItemRepositoryMockSaveOrUpdateCartItemParamPtrs{}
	}
	mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveOrUpdateCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveOrUpdateCartItem
}

// ExpectCartItemParam2 sets up expected param cartItem for CartItemRepository.SaveOrUpdateCartItem
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) ExpectCartItemParam2(cartItem domain.CartItem) *mCartItemRepositoryMockSaveOrUpdateCartItem {
	if mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Set")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation == nil {
		mmSaveOrUpdateCartItem.defaultExpectation = &CartItemRepositoryMockSaveOrUpdateCartItemExpectation{}
	}

	if mmSaveOrUpdateCartItem.defaultExpectation.params != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Expect")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs == nil {
		mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs = &CartItemRepositoryMockSaveOrUpdateCartItemParamPtrs{}
	}
	mmSaveOrUpdateCartItem.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmSaveOrUpdateCartItem.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmSaveOrUpdateCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartItemRepository.SaveOrUpdateCartItem
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Inspect(f func(ctx context.Context, cartItem domain.CartItem)) *mCartItemRepositoryMockSaveOrUpdateCartItem {
	if mmSaveOrUpdateCartItem.mock.inspectFuncSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("Inspect function is already set for CartItemRepositoryMock.SaveOrUpdateCartItem")
	}

	mmSaveOrUpdateCartItem.mock.inspectFuncSaveOrUpdateCartItem = f

	return mmSaveOrUpdateCartItem
}

// Return sets up results that will be returned by CartItemRepository.SaveOrUpdateCartItem
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Return(err error) *CartItemRepositoryMock {
	if mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Set")
	}

	if mmSaveOrUpdateCartItem.defaultExpectation == nil {
		mmSaveOrUpdateCartItem.defaultExpectation = &CartItemRepositoryMockSaveOrUpdateCartItemExpectation{mock: mmSaveOrUpdateCartItem.mock}
	}
	mmSaveOrUpdateCartItem.defaultExpectation.results = &CartItemRepositoryMockSaveOrUpdateCartItemResults{err}
	mmSaveOrUpdateCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveOrUpdateCartItem.mock
}

// Set uses given function f to mock the CartItemRepository.SaveOrUpdateCartItem method
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Set(f func(ctx context.Context, cartItem domain.CartItem) (err error)) *CartItemRepositoryMock {
	if mmSaveOrUpdateCartItem.defaultExpectation != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("Default expectation is already set for the CartItemRepository.SaveOrUpdateCartItem method")
	}

	if len(mmSaveOrUpdateCartItem.expectations) > 0 {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("Some expectations are already set for the CartItemRepository.SaveOrUpdateCartItem method")
	}

	mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem = f
	mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItemOrigin = minimock.CallerInfo(1)
	return mmSaveOrUpdateCartItem.mock
}

// When sets expectation for the CartItemRepository.SaveOrUpdateCartItem which will trigger the result defined by the following
// Then helper
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) When(ctx context.Context, cartItem domain.CartItem) *CartItemRepositoryMockSaveOrUpdateCartItemExpectation {
	if mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("CartItemRepositoryMock.SaveOrUpdateCartItem mock is already set by Set")
	}

	expectation := &CartItemRepositoryMockSaveOrUpdateCartItemExpectation{
		mock:               mmSaveOrUpdateCartItem.mock,
		params:             &CartItemRepositoryMockSaveOrUpdateCartItemParams{ctx, cartItem},
		expectationOrigins: CartItemRepositoryMockSaveOrUpdateCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveOrUpdateCartItem.expectations = append(mmSaveOrUpdateCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartItemRepository.SaveOrUpdateCartItem return parameters for the expectation previously defined by the When method
func (e *CartItemRepositoryMockSaveOrUpdateCartItemExpectation) Then(err error) *CartItemRepositoryMock {
	e.results = &CartItemRepositoryMockSaveOrUpdateCartItemResults{err}
	return e.mock
}

// Times sets number of times CartItemRepository.SaveOrUpdateCartItem should be invoked
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Times(n uint64) *mCartItemRepositoryMockSaveOrUpdateCartItem {
	if n == 0 {
		mmSaveOrUpdateCartItem.mock.t.Fatalf("Times of CartItemRepositoryMock.SaveOrUpdateCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveOrUpdateCartItem.expectedInvocations, n)
	mmSaveOrUpdateCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveOrUpdateCartItem
}

func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) invocationsDone() bool {
	if len(mmSaveOrUpdateCartItem.expectations) == 0 && mmSaveOrUpdateCartItem.defaultExpectation == nil && mmSaveOrUpdateCartItem.mock.funcSaveOrUpdateCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveOrUpdateCartItem.mock.afterSaveOrUpdateCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveOrUpdateCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveOrUpdateCartItem implements mm_carts.CartItemRepository
func (mmSaveOrUpdateCartItem *CartItemRepositoryMock) SaveOrUpdateCartItem(ctx context.Context, cartItem domain.CartItem) (err error) {
	mm_atomic.AddUint64(&mmSaveOrUpdateCartItem.beforeSaveOrUpdateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrUpdateCartItem.afterSaveOrUpdateCartItemCounter, 1)

	mmSaveOrUpdateCartItem.t.Helper()

	if mmSaveOrUpdateCartItem.inspectFuncSaveOrUpdateCartItem != nil {
		mmSaveOrUpdateCartItem.inspectFuncSaveOrUpdateCartItem(ctx, cartItem)
	}

	mm_params := CartItemRepositoryMockSaveOrUpdateCartItemParams{ctx, cartItem}

	// Record call args
	mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.mutex.Lock()
	mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.callArgs = append(mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.callArgs, &mm_params)
	mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.mutex.Unlock()

	for _, e := range mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.paramPtrs

		mm_got := CartItemRepositoryMockSaveOrUpdateCartItemParams{ctx, cartItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveOrUpdateCartItem.t.Errorf("CartItemRepositoryMock.SaveOrUpdateCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmSaveOrUpdateCartItem.t.Errorf("CartItemRepositoryMock.SaveOrUpdateCartItem got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrUpdateCartItem.t.Errorf("CartItemRepositoryMock.SaveOrUpdateCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrUpdateCartItem.SaveOrUpdateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrUpdateCartItem.t.Fatal("No results are set for the CartItemRepositoryMock.SaveOrUpdateCartItem")
		}
		return (*mm_results).err
	}
	if mmSaveOrUpdateCartItem.funcSaveOrUpdateCartItem != nil {
		return mmSaveOrUpdateCartItem.funcSaveOrUpdateCartItem(ctx, cartItem)
	}
	mmSaveOrUpdateCartItem.t.Fatalf("Unexpected call to CartItemRepositoryMock.SaveOrUpdateCartItem. %v %v", ctx, cartItem)
	return
}

// SaveOrUpdateCartItemAfterCounter returns a count of finished CartItemRepositoryMock.SaveOrUpdateCartItem invocations
func (mmSaveOrUpdateCartItem *CartItemRepositoryMock) SaveOrUpdateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrUpdateCartItem.afterSaveOrUpdateCartItemCounter)
}

// SaveOrUpdateCartItemBeforeCounter returns a count of CartItemRepositoryMock.SaveOrUpdateCartItem invocations
func (mmSaveOrUpdateCartItem *CartItemRepositoryMock) SaveOrUpdateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrUpdateCartItem.beforeSaveOrUpdateCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartItemRepositoryMock.SaveOrUpdateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrUpdateCartItem *mCartItemRepositoryMockSaveOrUpdateCartItem) Calls() []*CartItemRepositoryMockSaveOrUpdateCartItemParams {
	mmSaveOrUpdateCartItem.mutex.RLock()

	argCopy := make([]*CartItemRepositoryMockSaveOrUpdateCartItemParams, len(mmSaveOrUpdateCartItem.callArgs))
	copy(argCopy, mmSaveOrUpdateCartItem.callArgs)

	mmSaveOrUpdateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrUpdateCartItemDone returns true if the count of the SaveOrUpdateCartItem invocations corresponds
// the number of defined expectations
func (m *CartItemRepositoryMock) MinimockSaveOrUpdateCartItemDone() bool {
	if m.SaveOrUpdateCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveOrUpdateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveOrUpdateCartItemMock.invocationsDone()
}

// MinimockSaveOrUpdateCartItemInspect logs each unmet expectation
func (m *CartItemRepositoryMock) MinimockSaveOrUpdateCartItemInspect() {
	for _, e := range m.SaveOrUpdateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartItemRepositoryMock.SaveOrUpdateCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveOrUpdateCartItemCounter := mm_atomic.LoadUint64(&m.afterSaveOrUpdateCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrUpdateCartItemMock.defaultExpectation != nil && afterSaveOrUpdateCartItemCounter < 1 {
		if m.SaveOrUpdateCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartItemRepositoryMock.SaveOrUpdateCartItem at\n%s", m.SaveOrUpdateCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartItemRepositoryMock.SaveOrUpdateCartItem at\n%s with params: %#v", m.SaveOrUpdateCartItemMock.defaultExpectation.expectationOrigins.origin, *m.SaveOrUpdateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrUpdateCartItem != nil && afterSaveOrUpdateCartItemCounter < 1 {
		m.t.Errorf("Expected call to CartItemRepositoryMock.SaveOrUpdateCartItem at\n%s", m.funcSaveOrUpdateCartItemOrigin)
	}

	if !m.SaveOrUpdateCartItemMock.invocationsDone() && afterSaveOrUpdateCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartItemRepositoryMock.SaveOrUpdateCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveOrUpdateCartItemMock.expectedInvocations), m.SaveOrUpdateCartItemMock.expectedInvocationsOrigin, afterSaveOrUpdateCartItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartItemRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCartItemByUserIDInspect()

			m.MinimockListCartItemsByUserIDInspect()

			m.MinimockRemoveAllCartItemsInspect()

			m.MinimockRemoveCartItemInspect()

			m.MinimockSaveOrUpdateCartItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartItemRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartItemRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCartItemByUserIDDone() &&
		m.MinimockListCartItemsByUserIDDone() &&
		m.MinimockRemoveAllCartItemsDone() &&
		m.MinimockRemoveCartItemDone() &&
		m.MinimockSaveOrUpdateCartItemDone()
}
