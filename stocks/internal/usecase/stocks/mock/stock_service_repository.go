// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"stocks/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockServiceRepositoryMock implements mm_stocks.StockServiceRepository
type StockServiceRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCountStockItems          func(ctx context.Context, userID domain.UserID, location string) (u1 uint16, err error)
	funcCountStockItemsOrigin    string
	inspectFuncCountStockItems   func(ctx context.Context, userID domain.UserID, location string)
	afterCountStockItemsCounter  uint64
	beforeCountStockItemsCounter uint64
	CountStockItemsMock          mStockServiceRepositoryMockCountStockItems

	funcDeleteStockItemFromStorage          func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error)
	funcDeleteStockItemFromStorageOrigin    string
	inspectFuncDeleteStockItemFromStorage   func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)
	afterDeleteStockItemFromStorageCounter  uint64
	beforeDeleteStockItemFromStorageCounter uint64
	DeleteStockItemFromStorageMock          mStockServiceRepositoryMockDeleteStockItemFromStorage

	funcGetStockItem          func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (s1 domain.StockItem, err error)
	funcGetStockItemOrigin    string
	inspectFuncGetStockItem   func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)
	afterGetStockItemCounter  uint64
	beforeGetStockItemCounter uint64
	GetStockItemMock          mStockServiceRepositoryMockGetStockItem

	funcGetStockItemBySku          func(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error)
	funcGetStockItemBySkuOrigin    string
	inspectFuncGetStockItemBySku   func(ctx context.Context, skuID domain.SKUID)
	afterGetStockItemBySkuCounter  uint64
	beforeGetStockItemBySkuCounter uint64
	GetStockItemBySkuMock          mStockServiceRepositoryMockGetStockItemBySku

	funcListStockItemsByLocation          func(ctx context.Context, filter domain.Filter) (sa1 []domain.StockItem, err error)
	funcListStockItemsByLocationOrigin    string
	inspectFuncListStockItemsByLocation   func(ctx context.Context, filter domain.Filter)
	afterListStockItemsByLocationCounter  uint64
	beforeListStockItemsByLocationCounter uint64
	ListStockItemsByLocationMock          mStockServiceRepositoryMockListStockItemsByLocation

	funcSaveStockItem          func(ctx context.Context, stockItem domain.StockItem) (err error)
	funcSaveStockItemOrigin    string
	inspectFuncSaveStockItem   func(ctx context.Context, stockItem domain.StockItem)
	afterSaveStockItemCounter  uint64
	beforeSaveStockItemCounter uint64
	SaveStockItemMock          mStockServiceRepositoryMockSaveStockItem

	funcUpdateStockItem          func(ctx context.Context, stockItem domain.StockItem) (err error)
	funcUpdateStockItemOrigin    string
	inspectFuncUpdateStockItem   func(ctx context.Context, stockItem domain.StockItem)
	afterUpdateStockItemCounter  uint64
	beforeUpdateStockItemCounter uint64
	UpdateStockItemMock          mStockServiceRepositoryMockUpdateStockItem
}

// NewStockServiceRepositoryMock returns a mock for mm_stocks.StockServiceRepository
func NewStockServiceRepositoryMock(t minimock.Tester) *StockServiceRepositoryMock {
	m := &StockServiceRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CountStockItemsMock = mStockServiceRepositoryMockCountStockItems{mock: m}
	m.CountStockItemsMock.callArgs = []*StockServiceRepositoryMockCountStockItemsParams{}

	m.DeleteStockItemFromStorageMock = mStockServiceRepositoryMockDeleteStockItemFromStorage{mock: m}
	m.DeleteStockItemFromStorageMock.callArgs = []*StockServiceRepositoryMockDeleteStockItemFromStorageParams{}

	m.GetStockItemMock = mStockServiceRepositoryMockGetStockItem{mock: m}
	m.GetStockItemMock.callArgs = []*StockServiceRepositoryMockGetStockItemParams{}

	m.GetStockItemBySkuMock = mStockServiceRepositoryMockGetStockItemBySku{mock: m}
	m.GetStockItemBySkuMock.callArgs = []*StockServiceRepositoryMockGetStockItemBySkuParams{}

	m.ListStockItemsByLocationMock = mStockServiceRepositoryMockListStockItemsByLocation{mock: m}
	m.ListStockItemsByLocationMock.callArgs = []*StockServiceRepositoryMockListStockItemsByLocationParams{}

	m.SaveStockItemMock = mStockServiceRepositoryMockSaveStockItem{mock: m}
	m.SaveStockItemMock.callArgs = []*StockServiceRepositoryMockSaveStockItemParams{}

	m.UpdateStockItemMock = mStockServiceRepositoryMockUpdateStockItem{mock: m}
	m.UpdateStockItemMock.callArgs = []*StockServiceRepositoryMockUpdateStockItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockServiceRepositoryMockCountStockItems struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockCountStockItemsExpectation
	expectations       []*StockServiceRepositoryMockCountStockItemsExpectation

	callArgs []*StockServiceRepositoryMockCountStockItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockCountStockItemsExpectation specifies expectation struct of the StockServiceRepository.CountStockItems
type StockServiceRepositoryMockCountStockItemsExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockCountStockItemsParams
	paramPtrs          *StockServiceRepositoryMockCountStockItemsParamPtrs
	expectationOrigins StockServiceRepositoryMockCountStockItemsExpectationOrigins
	results            *StockServiceRepositoryMockCountStockItemsResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockCountStockItemsParams contains parameters of the StockServiceRepository.CountStockItems
type StockServiceRepositoryMockCountStockItemsParams struct {
	ctx      context.Context
	userID   domain.UserID
	location string
}

// StockServiceRepositoryMockCountStockItemsParamPtrs contains pointers to parameters of the StockServiceRepository.CountStockItems
type StockServiceRepositoryMockCountStockItemsParamPtrs struct {
	ctx      *context.Context
	userID   *domain.UserID
	location *string
}

// StockServiceRepositoryMockCountStockItemsResults contains results of the StockServiceRepository.CountStockItems
type StockServiceRepositoryMockCountStockItemsResults struct {
	u1  uint16
	err error
}

// StockServiceRepositoryMockCountStockItemsOrigins contains origins of expectations of the StockServiceRepository.CountStockItems
type StockServiceRepositoryMockCountStockItemsExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserID   string
	originLocation string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Optional() *mStockServiceRepositoryMockCountStockItems {
	mmCountStockItems.optional = true
	return mmCountStockItems
}

// Expect sets up expected params for StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Expect(ctx context.Context, userID domain.UserID, location string) *mStockServiceRepositoryMockCountStockItems {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	if mmCountStockItems.defaultExpectation == nil {
		mmCountStockItems.defaultExpectation = &StockServiceRepositoryMockCountStockItemsExpectation{}
	}

	if mmCountStockItems.defaultExpectation.paramPtrs != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by ExpectParams functions")
	}

	mmCountStockItems.defaultExpectation.params = &StockServiceRepositoryMockCountStockItemsParams{ctx, userID, location}
	mmCountStockItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCountStockItems.expectations {
		if minimock.Equal(e.params, mmCountStockItems.defaultExpectation.params) {
			mmCountStockItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCountStockItems.defaultExpectation.params)
		}
	}

	return mmCountStockItems
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockCountStockItems {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	if mmCountStockItems.defaultExpectation == nil {
		mmCountStockItems.defaultExpectation = &StockServiceRepositoryMockCountStockItemsExpectation{}
	}

	if mmCountStockItems.defaultExpectation.params != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Expect")
	}

	if mmCountStockItems.defaultExpectation.paramPtrs == nil {
		mmCountStockItems.defaultExpectation.paramPtrs = &StockServiceRepositoryMockCountStockItemsParamPtrs{}
	}
	mmCountStockItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmCountStockItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCountStockItems
}

// ExpectUserIDParam2 sets up expected param userID for StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) ExpectUserIDParam2(userID domain.UserID) *mStockServiceRepositoryMockCountStockItems {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	if mmCountStockItems.defaultExpectation == nil {
		mmCountStockItems.defaultExpectation = &StockServiceRepositoryMockCountStockItemsExpectation{}
	}

	if mmCountStockItems.defaultExpectation.params != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Expect")
	}

	if mmCountStockItems.defaultExpectation.paramPtrs == nil {
		mmCountStockItems.defaultExpectation.paramPtrs = &StockServiceRepositoryMockCountStockItemsParamPtrs{}
	}
	mmCountStockItems.defaultExpectation.paramPtrs.userID = &userID
	mmCountStockItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCountStockItems
}

// ExpectLocationParam3 sets up expected param location for StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) ExpectLocationParam3(location string) *mStockServiceRepositoryMockCountStockItems {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	if mmCountStockItems.defaultExpectation == nil {
		mmCountStockItems.defaultExpectation = &StockServiceRepositoryMockCountStockItemsExpectation{}
	}

	if mmCountStockItems.defaultExpectation.params != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Expect")
	}

	if mmCountStockItems.defaultExpectation.paramPtrs == nil {
		mmCountStockItems.defaultExpectation.paramPtrs = &StockServiceRepositoryMockCountStockItemsParamPtrs{}
	}
	mmCountStockItems.defaultExpectation.paramPtrs.location = &location
	mmCountStockItems.defaultExpectation.expectationOrigins.originLocation = minimock.CallerInfo(1)

	return mmCountStockItems
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Inspect(f func(ctx context.Context, userID domain.UserID, location string)) *mStockServiceRepositoryMockCountStockItems {
	if mmCountStockItems.mock.inspectFuncCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.CountStockItems")
	}

	mmCountStockItems.mock.inspectFuncCountStockItems = f

	return mmCountStockItems
}

// Return sets up results that will be returned by StockServiceRepository.CountStockItems
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Return(u1 uint16, err error) *StockServiceRepositoryMock {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	if mmCountStockItems.defaultExpectation == nil {
		mmCountStockItems.defaultExpectation = &StockServiceRepositoryMockCountStockItemsExpectation{mock: mmCountStockItems.mock}
	}
	mmCountStockItems.defaultExpectation.results = &StockServiceRepositoryMockCountStockItemsResults{u1, err}
	mmCountStockItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCountStockItems.mock
}

// Set uses given function f to mock the StockServiceRepository.CountStockItems method
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Set(f func(ctx context.Context, userID domain.UserID, location string) (u1 uint16, err error)) *StockServiceRepositoryMock {
	if mmCountStockItems.defaultExpectation != nil {
		mmCountStockItems.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.CountStockItems method")
	}

	if len(mmCountStockItems.expectations) > 0 {
		mmCountStockItems.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.CountStockItems method")
	}

	mmCountStockItems.mock.funcCountStockItems = f
	mmCountStockItems.mock.funcCountStockItemsOrigin = minimock.CallerInfo(1)
	return mmCountStockItems.mock
}

// When sets expectation for the StockServiceRepository.CountStockItems which will trigger the result defined by the following
// Then helper
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) When(ctx context.Context, userID domain.UserID, location string) *StockServiceRepositoryMockCountStockItemsExpectation {
	if mmCountStockItems.mock.funcCountStockItems != nil {
		mmCountStockItems.mock.t.Fatalf("StockServiceRepositoryMock.CountStockItems mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockCountStockItemsExpectation{
		mock:               mmCountStockItems.mock,
		params:             &StockServiceRepositoryMockCountStockItemsParams{ctx, userID, location},
		expectationOrigins: StockServiceRepositoryMockCountStockItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCountStockItems.expectations = append(mmCountStockItems.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.CountStockItems return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockCountStockItemsExpectation) Then(u1 uint16, err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockCountStockItemsResults{u1, err}
	return e.mock
}

// Times sets number of times StockServiceRepository.CountStockItems should be invoked
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Times(n uint64) *mStockServiceRepositoryMockCountStockItems {
	if n == 0 {
		mmCountStockItems.mock.t.Fatalf("Times of StockServiceRepositoryMock.CountStockItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCountStockItems.expectedInvocations, n)
	mmCountStockItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCountStockItems
}

func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) invocationsDone() bool {
	if len(mmCountStockItems.expectations) == 0 && mmCountStockItems.defaultExpectation == nil && mmCountStockItems.mock.funcCountStockItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCountStockItems.mock.afterCountStockItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCountStockItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CountStockItems implements mm_stocks.StockServiceRepository
func (mmCountStockItems *StockServiceRepositoryMock) CountStockItems(ctx context.Context, userID domain.UserID, location string) (u1 uint16, err error) {
	mm_atomic.AddUint64(&mmCountStockItems.beforeCountStockItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCountStockItems.afterCountStockItemsCounter, 1)

	mmCountStockItems.t.Helper()

	if mmCountStockItems.inspectFuncCountStockItems != nil {
		mmCountStockItems.inspectFuncCountStockItems(ctx, userID, location)
	}

	mm_params := StockServiceRepositoryMockCountStockItemsParams{ctx, userID, location}

	// Record call args
	mmCountStockItems.CountStockItemsMock.mutex.Lock()
	mmCountStockItems.CountStockItemsMock.callArgs = append(mmCountStockItems.CountStockItemsMock.callArgs, &mm_params)
	mmCountStockItems.CountStockItemsMock.mutex.Unlock()

	for _, e := range mmCountStockItems.CountStockItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCountStockItems.CountStockItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCountStockItems.CountStockItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCountStockItems.CountStockItemsMock.defaultExpectation.params
		mm_want_ptrs := mmCountStockItems.CountStockItemsMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockCountStockItemsParams{ctx, userID, location}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCountStockItems.t.Errorf("StockServiceRepositoryMock.CountStockItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountStockItems.CountStockItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCountStockItems.t.Errorf("StockServiceRepositoryMock.CountStockItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountStockItems.CountStockItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.location != nil && !minimock.Equal(*mm_want_ptrs.location, mm_got.location) {
				mmCountStockItems.t.Errorf("StockServiceRepositoryMock.CountStockItems got unexpected parameter location, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCountStockItems.CountStockItemsMock.defaultExpectation.expectationOrigins.originLocation, *mm_want_ptrs.location, mm_got.location, minimock.Diff(*mm_want_ptrs.location, mm_got.location))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCountStockItems.t.Errorf("StockServiceRepositoryMock.CountStockItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCountStockItems.CountStockItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCountStockItems.CountStockItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCountStockItems.t.Fatal("No results are set for the StockServiceRepositoryMock.CountStockItems")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCountStockItems.funcCountStockItems != nil {
		return mmCountStockItems.funcCountStockItems(ctx, userID, location)
	}
	mmCountStockItems.t.Fatalf("Unexpected call to StockServiceRepositoryMock.CountStockItems. %v %v %v", ctx, userID, location)
	return
}

// CountStockItemsAfterCounter returns a count of finished StockServiceRepositoryMock.CountStockItems invocations
func (mmCountStockItems *StockServiceRepositoryMock) CountStockItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStockItems.afterCountStockItemsCounter)
}

// CountStockItemsBeforeCounter returns a count of StockServiceRepositoryMock.CountStockItems invocations
func (mmCountStockItems *StockServiceRepositoryMock) CountStockItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCountStockItems.beforeCountStockItemsCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.CountStockItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCountStockItems *mStockServiceRepositoryMockCountStockItems) Calls() []*StockServiceRepositoryMockCountStockItemsParams {
	mmCountStockItems.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockCountStockItemsParams, len(mmCountStockItems.callArgs))
	copy(argCopy, mmCountStockItems.callArgs)

	mmCountStockItems.mutex.RUnlock()

	return argCopy
}

// MinimockCountStockItemsDone returns true if the count of the CountStockItems invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockCountStockItemsDone() bool {
	if m.CountStockItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CountStockItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CountStockItemsMock.invocationsDone()
}

// MinimockCountStockItemsInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockCountStockItemsInspect() {
	for _, e := range m.CountStockItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.CountStockItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCountStockItemsCounter := mm_atomic.LoadUint64(&m.afterCountStockItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CountStockItemsMock.defaultExpectation != nil && afterCountStockItemsCounter < 1 {
		if m.CountStockItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.CountStockItems at\n%s", m.CountStockItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.CountStockItems at\n%s with params: %#v", m.CountStockItemsMock.defaultExpectation.expectationOrigins.origin, *m.CountStockItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCountStockItems != nil && afterCountStockItemsCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.CountStockItems at\n%s", m.funcCountStockItemsOrigin)
	}

	if !m.CountStockItemsMock.invocationsDone() && afterCountStockItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.CountStockItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CountStockItemsMock.expectedInvocations), m.CountStockItemsMock.expectedInvocationsOrigin, afterCountStockItemsCounter)
	}
}

type mStockServiceRepositoryMockDeleteStockItemFromStorage struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockDeleteStockItemFromStorageExpectation
	expectations       []*StockServiceRepositoryMockDeleteStockItemFromStorageExpectation

	callArgs []*StockServiceRepositoryMockDeleteStockItemFromStorageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockDeleteStockItemFromStorageExpectation specifies expectation struct of the StockServiceRepository.DeleteStockItemFromStorage
type StockServiceRepositoryMockDeleteStockItemFromStorageExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockDeleteStockItemFromStorageParams
	paramPtrs          *StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs
	expectationOrigins StockServiceRepositoryMockDeleteStockItemFromStorageExpectationOrigins
	results            *StockServiceRepositoryMockDeleteStockItemFromStorageResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockDeleteStockItemFromStorageParams contains parameters of the StockServiceRepository.DeleteStockItemFromStorage
type StockServiceRepositoryMockDeleteStockItemFromStorageParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SKUID
}

// StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs contains pointers to parameters of the StockServiceRepository.DeleteStockItemFromStorage
type StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SKUID
}

// StockServiceRepositoryMockDeleteStockItemFromStorageResults contains results of the StockServiceRepository.DeleteStockItemFromStorage
type StockServiceRepositoryMockDeleteStockItemFromStorageResults struct {
	err error
}

// StockServiceRepositoryMockDeleteStockItemFromStorageOrigins contains origins of expectations of the StockServiceRepository.DeleteStockItemFromStorage
type StockServiceRepositoryMockDeleteStockItemFromStorageExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Optional() *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	mmDeleteStockItemFromStorage.optional = true
	return mmDeleteStockItemFromStorage
}

// Expect sets up expected params for StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Expect(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation == nil {
		mmDeleteStockItemFromStorage.defaultExpectation = &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{}
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by ExpectParams functions")
	}

	mmDeleteStockItemFromStorage.defaultExpectation.params = &StockServiceRepositoryMockDeleteStockItemFromStorageParams{ctx, userID, skuID}
	mmDeleteStockItemFromStorage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteStockItemFromStorage.expectations {
		if minimock.Equal(e.params, mmDeleteStockItemFromStorage.defaultExpectation.params) {
			mmDeleteStockItemFromStorage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStockItemFromStorage.defaultExpectation.params)
		}
	}

	return mmDeleteStockItemFromStorage
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation == nil {
		mmDeleteStockItemFromStorage.defaultExpectation = &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{}
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.params != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Expect")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs = &StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs{}
	}
	mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteStockItemFromStorage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteStockItemFromStorage
}

// ExpectUserIDParam2 sets up expected param userID for StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) ExpectUserIDParam2(userID domain.UserID) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation == nil {
		mmDeleteStockItemFromStorage.defaultExpectation = &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{}
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.params != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Expect")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs = &StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs{}
	}
	mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteStockItemFromStorage.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteStockItemFromStorage
}

// ExpectSkuIDParam3 sets up expected param skuID for StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) ExpectSkuIDParam3(skuID domain.SKUID) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation == nil {
		mmDeleteStockItemFromStorage.defaultExpectation = &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{}
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.params != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Expect")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs = &StockServiceRepositoryMockDeleteStockItemFromStorageParamPtrs{}
	}
	mmDeleteStockItemFromStorage.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteStockItemFromStorage.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteStockItemFromStorage
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if mmDeleteStockItemFromStorage.mock.inspectFuncDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.DeleteStockItemFromStorage")
	}

	mmDeleteStockItemFromStorage.mock.inspectFuncDeleteStockItemFromStorage = f

	return mmDeleteStockItemFromStorage
}

// Return sets up results that will be returned by StockServiceRepository.DeleteStockItemFromStorage
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Return(err error) *StockServiceRepositoryMock {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	if mmDeleteStockItemFromStorage.defaultExpectation == nil {
		mmDeleteStockItemFromStorage.defaultExpectation = &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{mock: mmDeleteStockItemFromStorage.mock}
	}
	mmDeleteStockItemFromStorage.defaultExpectation.results = &StockServiceRepositoryMockDeleteStockItemFromStorageResults{err}
	mmDeleteStockItemFromStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItemFromStorage.mock
}

// Set uses given function f to mock the StockServiceRepository.DeleteStockItemFromStorage method
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error)) *StockServiceRepositoryMock {
	if mmDeleteStockItemFromStorage.defaultExpectation != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.DeleteStockItemFromStorage method")
	}

	if len(mmDeleteStockItemFromStorage.expectations) > 0 {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.DeleteStockItemFromStorage method")
	}

	mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage = f
	mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorageOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItemFromStorage.mock
}

// When sets expectation for the StockServiceRepository.DeleteStockItemFromStorage which will trigger the result defined by the following
// Then helper
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) When(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *StockServiceRepositoryMockDeleteStockItemFromStorageExpectation {
	if mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("StockServiceRepositoryMock.DeleteStockItemFromStorage mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockDeleteStockItemFromStorageExpectation{
		mock:               mmDeleteStockItemFromStorage.mock,
		params:             &StockServiceRepositoryMockDeleteStockItemFromStorageParams{ctx, userID, skuID},
		expectationOrigins: StockServiceRepositoryMockDeleteStockItemFromStorageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteStockItemFromStorage.expectations = append(mmDeleteStockItemFromStorage.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.DeleteStockItemFromStorage return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockDeleteStockItemFromStorageExpectation) Then(err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockDeleteStockItemFromStorageResults{err}
	return e.mock
}

// Times sets number of times StockServiceRepository.DeleteStockItemFromStorage should be invoked
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Times(n uint64) *mStockServiceRepositoryMockDeleteStockItemFromStorage {
	if n == 0 {
		mmDeleteStockItemFromStorage.mock.t.Fatalf("Times of StockServiceRepositoryMock.DeleteStockItemFromStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteStockItemFromStorage.expectedInvocations, n)
	mmDeleteStockItemFromStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItemFromStorage
}

func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) invocationsDone() bool {
	if len(mmDeleteStockItemFromStorage.expectations) == 0 && mmDeleteStockItemFromStorage.defaultExpectation == nil && mmDeleteStockItemFromStorage.mock.funcDeleteStockItemFromStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteStockItemFromStorage.mock.afterDeleteStockItemFromStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteStockItemFromStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteStockItemFromStorage implements mm_stocks.StockServiceRepository
func (mmDeleteStockItemFromStorage *StockServiceRepositoryMock) DeleteStockItemFromStorage(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteStockItemFromStorage.beforeDeleteStockItemFromStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStockItemFromStorage.afterDeleteStockItemFromStorageCounter, 1)

	mmDeleteStockItemFromStorage.t.Helper()

	if mmDeleteStockItemFromStorage.inspectFuncDeleteStockItemFromStorage != nil {
		mmDeleteStockItemFromStorage.inspectFuncDeleteStockItemFromStorage(ctx, userID, skuID)
	}

	mm_params := StockServiceRepositoryMockDeleteStockItemFromStorageParams{ctx, userID, skuID}

	// Record call args
	mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.mutex.Lock()
	mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.callArgs = append(mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.callArgs, &mm_params)
	mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.mutex.Unlock()

	for _, e := range mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockDeleteStockItemFromStorageParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteStockItemFromStorage.t.Errorf("StockServiceRepositoryMock.DeleteStockItemFromStorage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteStockItemFromStorage.t.Errorf("StockServiceRepositoryMock.DeleteStockItemFromStorage got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteStockItemFromStorage.t.Errorf("StockServiceRepositoryMock.DeleteStockItemFromStorage got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStockItemFromStorage.t.Errorf("StockServiceRepositoryMock.DeleteStockItemFromStorage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteStockItemFromStorage.DeleteStockItemFromStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteStockItemFromStorage.t.Fatal("No results are set for the StockServiceRepositoryMock.DeleteStockItemFromStorage")
		}
		return (*mm_results).err
	}
	if mmDeleteStockItemFromStorage.funcDeleteStockItemFromStorage != nil {
		return mmDeleteStockItemFromStorage.funcDeleteStockItemFromStorage(ctx, userID, skuID)
	}
	mmDeleteStockItemFromStorage.t.Fatalf("Unexpected call to StockServiceRepositoryMock.DeleteStockItemFromStorage. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteStockItemFromStorageAfterCounter returns a count of finished StockServiceRepositoryMock.DeleteStockItemFromStorage invocations
func (mmDeleteStockItemFromStorage *StockServiceRepositoryMock) DeleteStockItemFromStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockItemFromStorage.afterDeleteStockItemFromStorageCounter)
}

// DeleteStockItemFromStorageBeforeCounter returns a count of StockServiceRepositoryMock.DeleteStockItemFromStorage invocations
func (mmDeleteStockItemFromStorage *StockServiceRepositoryMock) DeleteStockItemFromStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockItemFromStorage.beforeDeleteStockItemFromStorageCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.DeleteStockItemFromStorage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStockItemFromStorage *mStockServiceRepositoryMockDeleteStockItemFromStorage) Calls() []*StockServiceRepositoryMockDeleteStockItemFromStorageParams {
	mmDeleteStockItemFromStorage.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockDeleteStockItemFromStorageParams, len(mmDeleteStockItemFromStorage.callArgs))
	copy(argCopy, mmDeleteStockItemFromStorage.callArgs)

	mmDeleteStockItemFromStorage.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStockItemFromStorageDone returns true if the count of the DeleteStockItemFromStorage invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockDeleteStockItemFromStorageDone() bool {
	if m.DeleteStockItemFromStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteStockItemFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteStockItemFromStorageMock.invocationsDone()
}

// MinimockDeleteStockItemFromStorageInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockDeleteStockItemFromStorageInspect() {
	for _, e := range m.DeleteStockItemFromStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.DeleteStockItemFromStorage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteStockItemFromStorageCounter := mm_atomic.LoadUint64(&m.afterDeleteStockItemFromStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStockItemFromStorageMock.defaultExpectation != nil && afterDeleteStockItemFromStorageCounter < 1 {
		if m.DeleteStockItemFromStorageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.DeleteStockItemFromStorage at\n%s", m.DeleteStockItemFromStorageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.DeleteStockItemFromStorage at\n%s with params: %#v", m.DeleteStockItemFromStorageMock.defaultExpectation.expectationOrigins.origin, *m.DeleteStockItemFromStorageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStockItemFromStorage != nil && afterDeleteStockItemFromStorageCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.DeleteStockItemFromStorage at\n%s", m.funcDeleteStockItemFromStorageOrigin)
	}

	if !m.DeleteStockItemFromStorageMock.invocationsDone() && afterDeleteStockItemFromStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.DeleteStockItemFromStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteStockItemFromStorageMock.expectedInvocations), m.DeleteStockItemFromStorageMock.expectedInvocationsOrigin, afterDeleteStockItemFromStorageCounter)
	}
}

type mStockServiceRepositoryMockGetStockItem struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockGetStockItemExpectation
	expectations       []*StockServiceRepositoryMockGetStockItemExpectation

	callArgs []*StockServiceRepositoryMockGetStockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockGetStockItemExpectation specifies expectation struct of the StockServiceRepository.GetStockItem
type StockServiceRepositoryMockGetStockItemExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockGetStockItemParams
	paramPtrs          *StockServiceRepositoryMockGetStockItemParamPtrs
	expectationOrigins StockServiceRepositoryMockGetStockItemExpectationOrigins
	results            *StockServiceRepositoryMockGetStockItemResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockGetStockItemParams contains parameters of the StockServiceRepository.GetStockItem
type StockServiceRepositoryMockGetStockItemParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SKUID
}

// StockServiceRepositoryMockGetStockItemParamPtrs contains pointers to parameters of the StockServiceRepository.GetStockItem
type StockServiceRepositoryMockGetStockItemParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SKUID
}

// StockServiceRepositoryMockGetStockItemResults contains results of the StockServiceRepository.GetStockItem
type StockServiceRepositoryMockGetStockItemResults struct {
	s1  domain.StockItem
	err error
}

// StockServiceRepositoryMockGetStockItemOrigins contains origins of expectations of the StockServiceRepository.GetStockItem
type StockServiceRepositoryMockGetStockItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Optional() *mStockServiceRepositoryMockGetStockItem {
	mmGetStockItem.optional = true
	return mmGetStockItem
}

// Expect sets up expected params for StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Expect(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *mStockServiceRepositoryMockGetStockItem {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	if mmGetStockItem.defaultExpectation == nil {
		mmGetStockItem.defaultExpectation = &StockServiceRepositoryMockGetStockItemExpectation{}
	}

	if mmGetStockItem.defaultExpectation.paramPtrs != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by ExpectParams functions")
	}

	mmGetStockItem.defaultExpectation.params = &StockServiceRepositoryMockGetStockItemParams{ctx, userID, skuID}
	mmGetStockItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStockItem.expectations {
		if minimock.Equal(e.params, mmGetStockItem.defaultExpectation.params) {
			mmGetStockItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStockItem.defaultExpectation.params)
		}
	}

	return mmGetStockItem
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockGetStockItem {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	if mmGetStockItem.defaultExpectation == nil {
		mmGetStockItem.defaultExpectation = &StockServiceRepositoryMockGetStockItemExpectation{}
	}

	if mmGetStockItem.defaultExpectation.params != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Expect")
	}

	if mmGetStockItem.defaultExpectation.paramPtrs == nil {
		mmGetStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockGetStockItemParamPtrs{}
	}
	mmGetStockItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStockItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStockItem
}

// ExpectUserIDParam2 sets up expected param userID for StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) ExpectUserIDParam2(userID domain.UserID) *mStockServiceRepositoryMockGetStockItem {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	if mmGetStockItem.defaultExpectation == nil {
		mmGetStockItem.defaultExpectation = &StockServiceRepositoryMockGetStockItemExpectation{}
	}

	if mmGetStockItem.defaultExpectation.params != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Expect")
	}

	if mmGetStockItem.defaultExpectation.paramPtrs == nil {
		mmGetStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockGetStockItemParamPtrs{}
	}
	mmGetStockItem.defaultExpectation.paramPtrs.userID = &userID
	mmGetStockItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetStockItem
}

// ExpectSkuIDParam3 sets up expected param skuID for StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) ExpectSkuIDParam3(skuID domain.SKUID) *mStockServiceRepositoryMockGetStockItem {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	if mmGetStockItem.defaultExpectation == nil {
		mmGetStockItem.defaultExpectation = &StockServiceRepositoryMockGetStockItemExpectation{}
	}

	if mmGetStockItem.defaultExpectation.params != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Expect")
	}

	if mmGetStockItem.defaultExpectation.paramPtrs == nil {
		mmGetStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockGetStockItemParamPtrs{}
	}
	mmGetStockItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetStockItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetStockItem
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)) *mStockServiceRepositoryMockGetStockItem {
	if mmGetStockItem.mock.inspectFuncGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.GetStockItem")
	}

	mmGetStockItem.mock.inspectFuncGetStockItem = f

	return mmGetStockItem
}

// Return sets up results that will be returned by StockServiceRepository.GetStockItem
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Return(s1 domain.StockItem, err error) *StockServiceRepositoryMock {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	if mmGetStockItem.defaultExpectation == nil {
		mmGetStockItem.defaultExpectation = &StockServiceRepositoryMockGetStockItemExpectation{mock: mmGetStockItem.mock}
	}
	mmGetStockItem.defaultExpectation.results = &StockServiceRepositoryMockGetStockItemResults{s1, err}
	mmGetStockItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStockItem.mock
}

// Set uses given function f to mock the StockServiceRepository.GetStockItem method
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (s1 domain.StockItem, err error)) *StockServiceRepositoryMock {
	if mmGetStockItem.defaultExpectation != nil {
		mmGetStockItem.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.GetStockItem method")
	}

	if len(mmGetStockItem.expectations) > 0 {
		mmGetStockItem.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.GetStockItem method")
	}

	mmGetStockItem.mock.funcGetStockItem = f
	mmGetStockItem.mock.funcGetStockItemOrigin = minimock.CallerInfo(1)
	return mmGetStockItem.mock
}

// When sets expectation for the StockServiceRepository.GetStockItem which will trigger the result defined by the following
// Then helper
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) When(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *StockServiceRepositoryMockGetStockItemExpectation {
	if mmGetStockItem.mock.funcGetStockItem != nil {
		mmGetStockItem.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItem mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockGetStockItemExpectation{
		mock:               mmGetStockItem.mock,
		params:             &StockServiceRepositoryMockGetStockItemParams{ctx, userID, skuID},
		expectationOrigins: StockServiceRepositoryMockGetStockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStockItem.expectations = append(mmGetStockItem.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.GetStockItem return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockGetStockItemExpectation) Then(s1 domain.StockItem, err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockGetStockItemResults{s1, err}
	return e.mock
}

// Times sets number of times StockServiceRepository.GetStockItem should be invoked
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Times(n uint64) *mStockServiceRepositoryMockGetStockItem {
	if n == 0 {
		mmGetStockItem.mock.t.Fatalf("Times of StockServiceRepositoryMock.GetStockItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStockItem.expectedInvocations, n)
	mmGetStockItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStockItem
}

func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) invocationsDone() bool {
	if len(mmGetStockItem.expectations) == 0 && mmGetStockItem.defaultExpectation == nil && mmGetStockItem.mock.funcGetStockItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStockItem.mock.afterGetStockItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStockItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStockItem implements mm_stocks.StockServiceRepository
func (mmGetStockItem *StockServiceRepositoryMock) GetStockItem(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (s1 domain.StockItem, err error) {
	mm_atomic.AddUint64(&mmGetStockItem.beforeGetStockItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStockItem.afterGetStockItemCounter, 1)

	mmGetStockItem.t.Helper()

	if mmGetStockItem.inspectFuncGetStockItem != nil {
		mmGetStockItem.inspectFuncGetStockItem(ctx, userID, skuID)
	}

	mm_params := StockServiceRepositoryMockGetStockItemParams{ctx, userID, skuID}

	// Record call args
	mmGetStockItem.GetStockItemMock.mutex.Lock()
	mmGetStockItem.GetStockItemMock.callArgs = append(mmGetStockItem.GetStockItemMock.callArgs, &mm_params)
	mmGetStockItem.GetStockItemMock.mutex.Unlock()

	for _, e := range mmGetStockItem.GetStockItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStockItem.GetStockItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStockItem.GetStockItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStockItem.GetStockItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetStockItem.GetStockItemMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockGetStockItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStockItem.t.Errorf("StockServiceRepositoryMock.GetStockItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItem.GetStockItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetStockItem.t.Errorf("StockServiceRepositoryMock.GetStockItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItem.GetStockItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetStockItem.t.Errorf("StockServiceRepositoryMock.GetStockItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItem.GetStockItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStockItem.t.Errorf("StockServiceRepositoryMock.GetStockItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStockItem.GetStockItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStockItem.GetStockItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStockItem.t.Fatal("No results are set for the StockServiceRepositoryMock.GetStockItem")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStockItem.funcGetStockItem != nil {
		return mmGetStockItem.funcGetStockItem(ctx, userID, skuID)
	}
	mmGetStockItem.t.Fatalf("Unexpected call to StockServiceRepositoryMock.GetStockItem. %v %v %v", ctx, userID, skuID)
	return
}

// GetStockItemAfterCounter returns a count of finished StockServiceRepositoryMock.GetStockItem invocations
func (mmGetStockItem *StockServiceRepositoryMock) GetStockItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItem.afterGetStockItemCounter)
}

// GetStockItemBeforeCounter returns a count of StockServiceRepositoryMock.GetStockItem invocations
func (mmGetStockItem *StockServiceRepositoryMock) GetStockItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItem.beforeGetStockItemCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.GetStockItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStockItem *mStockServiceRepositoryMockGetStockItem) Calls() []*StockServiceRepositoryMockGetStockItemParams {
	mmGetStockItem.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockGetStockItemParams, len(mmGetStockItem.callArgs))
	copy(argCopy, mmGetStockItem.callArgs)

	mmGetStockItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockItemDone returns true if the count of the GetStockItem invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockGetStockItemDone() bool {
	if m.GetStockItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockItemMock.invocationsDone()
}

// MinimockGetStockItemInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockGetStockItemInspect() {
	for _, e := range m.GetStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockItemCounter := mm_atomic.LoadUint64(&m.afterGetStockItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockItemMock.defaultExpectation != nil && afterGetStockItemCounter < 1 {
		if m.GetStockItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItem at\n%s", m.GetStockItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItem at\n%s with params: %#v", m.GetStockItemMock.defaultExpectation.expectationOrigins.origin, *m.GetStockItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStockItem != nil && afterGetStockItemCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItem at\n%s", m.funcGetStockItemOrigin)
	}

	if !m.GetStockItemMock.invocationsDone() && afterGetStockItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.GetStockItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockItemMock.expectedInvocations), m.GetStockItemMock.expectedInvocationsOrigin, afterGetStockItemCounter)
	}
}

type mStockServiceRepositoryMockGetStockItemBySku struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockGetStockItemBySkuExpectation
	expectations       []*StockServiceRepositoryMockGetStockItemBySkuExpectation

	callArgs []*StockServiceRepositoryMockGetStockItemBySkuParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockGetStockItemBySkuExpectation specifies expectation struct of the StockServiceRepository.GetStockItemBySku
type StockServiceRepositoryMockGetStockItemBySkuExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockGetStockItemBySkuParams
	paramPtrs          *StockServiceRepositoryMockGetStockItemBySkuParamPtrs
	expectationOrigins StockServiceRepositoryMockGetStockItemBySkuExpectationOrigins
	results            *StockServiceRepositoryMockGetStockItemBySkuResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockGetStockItemBySkuParams contains parameters of the StockServiceRepository.GetStockItemBySku
type StockServiceRepositoryMockGetStockItemBySkuParams struct {
	ctx   context.Context
	skuID domain.SKUID
}

// StockServiceRepositoryMockGetStockItemBySkuParamPtrs contains pointers to parameters of the StockServiceRepository.GetStockItemBySku
type StockServiceRepositoryMockGetStockItemBySkuParamPtrs struct {
	ctx   *context.Context
	skuID *domain.SKUID
}

// StockServiceRepositoryMockGetStockItemBySkuResults contains results of the StockServiceRepository.GetStockItemBySku
type StockServiceRepositoryMockGetStockItemBySkuResults struct {
	s1  domain.StockItem
	err error
}

// StockServiceRepositoryMockGetStockItemBySkuOrigins contains origins of expectations of the StockServiceRepository.GetStockItemBySku
type StockServiceRepositoryMockGetStockItemBySkuExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Optional() *mStockServiceRepositoryMockGetStockItemBySku {
	mmGetStockItemBySku.optional = true
	return mmGetStockItemBySku
}

// Expect sets up expected params for StockServiceRepository.GetStockItemBySku
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Expect(ctx context.Context, skuID domain.SKUID) *mStockServiceRepositoryMockGetStockItemBySku {
	if mmGetStockItemBySku.mock.funcGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Set")
	}

	if mmGetStockItemBySku.defaultExpectation == nil {
		mmGetStockItemBySku.defaultExpectation = &StockServiceRepositoryMockGetStockItemBySkuExpectation{}
	}

	if mmGetStockItemBySku.defaultExpectation.paramPtrs != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by ExpectParams functions")
	}

	mmGetStockItemBySku.defaultExpectation.params = &StockServiceRepositoryMockGetStockItemBySkuParams{ctx, skuID}
	mmGetStockItemBySku.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStockItemBySku.expectations {
		if minimock.Equal(e.params, mmGetStockItemBySku.defaultExpectation.params) {
			mmGetStockItemBySku.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStockItemBySku.defaultExpectation.params)
		}
	}

	return mmGetStockItemBySku
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.GetStockItemBySku
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockGetStockItemBySku {
	if mmGetStockItemBySku.mock.funcGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Set")
	}

	if mmGetStockItemBySku.defaultExpectation == nil {
		mmGetStockItemBySku.defaultExpectation = &StockServiceRepositoryMockGetStockItemBySkuExpectation{}
	}

	if mmGetStockItemBySku.defaultExpectation.params != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Expect")
	}

	if mmGetStockItemBySku.defaultExpectation.paramPtrs == nil {
		mmGetStockItemBySku.defaultExpectation.paramPtrs = &StockServiceRepositoryMockGetStockItemBySkuParamPtrs{}
	}
	mmGetStockItemBySku.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStockItemBySku.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStockItemBySku
}

// ExpectSkuIDParam2 sets up expected param skuID for StockServiceRepository.GetStockItemBySku
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) ExpectSkuIDParam2(skuID domain.SKUID) *mStockServiceRepositoryMockGetStockItemBySku {
	if mmGetStockItemBySku.mock.funcGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Set")
	}

	if mmGetStockItemBySku.defaultExpectation == nil {
		mmGetStockItemBySku.defaultExpectation = &StockServiceRepositoryMockGetStockItemBySkuExpectation{}
	}

	if mmGetStockItemBySku.defaultExpectation.params != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Expect")
	}

	if mmGetStockItemBySku.defaultExpectation.paramPtrs == nil {
		mmGetStockItemBySku.defaultExpectation.paramPtrs = &StockServiceRepositoryMockGetStockItemBySkuParamPtrs{}
	}
	mmGetStockItemBySku.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetStockItemBySku.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetStockItemBySku
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.GetStockItemBySku
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Inspect(f func(ctx context.Context, skuID domain.SKUID)) *mStockServiceRepositoryMockGetStockItemBySku {
	if mmGetStockItemBySku.mock.inspectFuncGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.GetStockItemBySku")
	}

	mmGetStockItemBySku.mock.inspectFuncGetStockItemBySku = f

	return mmGetStockItemBySku
}

// Return sets up results that will be returned by StockServiceRepository.GetStockItemBySku
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Return(s1 domain.StockItem, err error) *StockServiceRepositoryMock {
	if mmGetStockItemBySku.mock.funcGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Set")
	}

	if mmGetStockItemBySku.defaultExpectation == nil {
		mmGetStockItemBySku.defaultExpectation = &StockServiceRepositoryMockGetStockItemBySkuExpectation{mock: mmGetStockItemBySku.mock}
	}
	mmGetStockItemBySku.defaultExpectation.results = &StockServiceRepositoryMockGetStockItemBySkuResults{s1, err}
	mmGetStockItemBySku.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySku.mock
}

// Set uses given function f to mock the StockServiceRepository.GetStockItemBySku method
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Set(f func(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error)) *StockServiceRepositoryMock {
	if mmGetStockItemBySku.defaultExpectation != nil {
		mmGetStockItemBySku.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.GetStockItemBySku method")
	}

	if len(mmGetStockItemBySku.expectations) > 0 {
		mmGetStockItemBySku.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.GetStockItemBySku method")
	}

	mmGetStockItemBySku.mock.funcGetStockItemBySku = f
	mmGetStockItemBySku.mock.funcGetStockItemBySkuOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySku.mock
}

// When sets expectation for the StockServiceRepository.GetStockItemBySku which will trigger the result defined by the following
// Then helper
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) When(ctx context.Context, skuID domain.SKUID) *StockServiceRepositoryMockGetStockItemBySkuExpectation {
	if mmGetStockItemBySku.mock.funcGetStockItemBySku != nil {
		mmGetStockItemBySku.mock.t.Fatalf("StockServiceRepositoryMock.GetStockItemBySku mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockGetStockItemBySkuExpectation{
		mock:               mmGetStockItemBySku.mock,
		params:             &StockServiceRepositoryMockGetStockItemBySkuParams{ctx, skuID},
		expectationOrigins: StockServiceRepositoryMockGetStockItemBySkuExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStockItemBySku.expectations = append(mmGetStockItemBySku.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.GetStockItemBySku return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockGetStockItemBySkuExpectation) Then(s1 domain.StockItem, err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockGetStockItemBySkuResults{s1, err}
	return e.mock
}

// Times sets number of times StockServiceRepository.GetStockItemBySku should be invoked
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Times(n uint64) *mStockServiceRepositoryMockGetStockItemBySku {
	if n == 0 {
		mmGetStockItemBySku.mock.t.Fatalf("Times of StockServiceRepositoryMock.GetStockItemBySku mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStockItemBySku.expectedInvocations, n)
	mmGetStockItemBySku.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySku
}

func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) invocationsDone() bool {
	if len(mmGetStockItemBySku.expectations) == 0 && mmGetStockItemBySku.defaultExpectation == nil && mmGetStockItemBySku.mock.funcGetStockItemBySku == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStockItemBySku.mock.afterGetStockItemBySkuCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStockItemBySku.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStockItemBySku implements mm_stocks.StockServiceRepository
func (mmGetStockItemBySku *StockServiceRepositoryMock) GetStockItemBySku(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error) {
	mm_atomic.AddUint64(&mmGetStockItemBySku.beforeGetStockItemBySkuCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStockItemBySku.afterGetStockItemBySkuCounter, 1)

	mmGetStockItemBySku.t.Helper()

	if mmGetStockItemBySku.inspectFuncGetStockItemBySku != nil {
		mmGetStockItemBySku.inspectFuncGetStockItemBySku(ctx, skuID)
	}

	mm_params := StockServiceRepositoryMockGetStockItemBySkuParams{ctx, skuID}

	// Record call args
	mmGetStockItemBySku.GetStockItemBySkuMock.mutex.Lock()
	mmGetStockItemBySku.GetStockItemBySkuMock.callArgs = append(mmGetStockItemBySku.GetStockItemBySkuMock.callArgs, &mm_params)
	mmGetStockItemBySku.GetStockItemBySkuMock.mutex.Unlock()

	for _, e := range mmGetStockItemBySku.GetStockItemBySkuMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.params
		mm_want_ptrs := mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockGetStockItemBySkuParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStockItemBySku.t.Errorf("StockServiceRepositoryMock.GetStockItemBySku got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetStockItemBySku.t.Errorf("StockServiceRepositoryMock.GetStockItemBySku got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStockItemBySku.t.Errorf("StockServiceRepositoryMock.GetStockItemBySku got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStockItemBySku.GetStockItemBySkuMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStockItemBySku.t.Fatal("No results are set for the StockServiceRepositoryMock.GetStockItemBySku")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStockItemBySku.funcGetStockItemBySku != nil {
		return mmGetStockItemBySku.funcGetStockItemBySku(ctx, skuID)
	}
	mmGetStockItemBySku.t.Fatalf("Unexpected call to StockServiceRepositoryMock.GetStockItemBySku. %v %v", ctx, skuID)
	return
}

// GetStockItemBySkuAfterCounter returns a count of finished StockServiceRepositoryMock.GetStockItemBySku invocations
func (mmGetStockItemBySku *StockServiceRepositoryMock) GetStockItemBySkuAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItemBySku.afterGetStockItemBySkuCounter)
}

// GetStockItemBySkuBeforeCounter returns a count of StockServiceRepositoryMock.GetStockItemBySku invocations
func (mmGetStockItemBySku *StockServiceRepositoryMock) GetStockItemBySkuBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItemBySku.beforeGetStockItemBySkuCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.GetStockItemBySku.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStockItemBySku *mStockServiceRepositoryMockGetStockItemBySku) Calls() []*StockServiceRepositoryMockGetStockItemBySkuParams {
	mmGetStockItemBySku.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockGetStockItemBySkuParams, len(mmGetStockItemBySku.callArgs))
	copy(argCopy, mmGetStockItemBySku.callArgs)

	mmGetStockItemBySku.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockItemBySkuDone returns true if the count of the GetStockItemBySku invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockGetStockItemBySkuDone() bool {
	if m.GetStockItemBySkuMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockItemBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockItemBySkuMock.invocationsDone()
}

// MinimockGetStockItemBySkuInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockGetStockItemBySkuInspect() {
	for _, e := range m.GetStockItemBySkuMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItemBySku at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockItemBySkuCounter := mm_atomic.LoadUint64(&m.afterGetStockItemBySkuCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockItemBySkuMock.defaultExpectation != nil && afterGetStockItemBySkuCounter < 1 {
		if m.GetStockItemBySkuMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItemBySku at\n%s", m.GetStockItemBySkuMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItemBySku at\n%s with params: %#v", m.GetStockItemBySkuMock.defaultExpectation.expectationOrigins.origin, *m.GetStockItemBySkuMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStockItemBySku != nil && afterGetStockItemBySkuCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.GetStockItemBySku at\n%s", m.funcGetStockItemBySkuOrigin)
	}

	if !m.GetStockItemBySkuMock.invocationsDone() && afterGetStockItemBySkuCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.GetStockItemBySku at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockItemBySkuMock.expectedInvocations), m.GetStockItemBySkuMock.expectedInvocationsOrigin, afterGetStockItemBySkuCounter)
	}
}

type mStockServiceRepositoryMockListStockItemsByLocation struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockListStockItemsByLocationExpectation
	expectations       []*StockServiceRepositoryMockListStockItemsByLocationExpectation

	callArgs []*StockServiceRepositoryMockListStockItemsByLocationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockListStockItemsByLocationExpectation specifies expectation struct of the StockServiceRepository.ListStockItemsByLocation
type StockServiceRepositoryMockListStockItemsByLocationExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockListStockItemsByLocationParams
	paramPtrs          *StockServiceRepositoryMockListStockItemsByLocationParamPtrs
	expectationOrigins StockServiceRepositoryMockListStockItemsByLocationExpectationOrigins
	results            *StockServiceRepositoryMockListStockItemsByLocationResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockListStockItemsByLocationParams contains parameters of the StockServiceRepository.ListStockItemsByLocation
type StockServiceRepositoryMockListStockItemsByLocationParams struct {
	ctx    context.Context
	filter domain.Filter
}

// StockServiceRepositoryMockListStockItemsByLocationParamPtrs contains pointers to parameters of the StockServiceRepository.ListStockItemsByLocation
type StockServiceRepositoryMockListStockItemsByLocationParamPtrs struct {
	ctx    *context.Context
	filter *domain.Filter
}

// StockServiceRepositoryMockListStockItemsByLocationResults contains results of the StockServiceRepository.ListStockItemsByLocation
type StockServiceRepositoryMockListStockItemsByLocationResults struct {
	sa1 []domain.StockItem
	err error
}

// StockServiceRepositoryMockListStockItemsByLocationOrigins contains origins of expectations of the StockServiceRepository.ListStockItemsByLocation
type StockServiceRepositoryMockListStockItemsByLocationExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Optional() *mStockServiceRepositoryMockListStockItemsByLocation {
	mmListStockItemsByLocation.optional = true
	return mmListStockItemsByLocation
}

// Expect sets up expected params for StockServiceRepository.ListStockItemsByLocation
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Expect(ctx context.Context, filter domain.Filter) *mStockServiceRepositoryMockListStockItemsByLocation {
	if mmListStockItemsByLocation.mock.funcListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Set")
	}

	if mmListStockItemsByLocation.defaultExpectation == nil {
		mmListStockItemsByLocation.defaultExpectation = &StockServiceRepositoryMockListStockItemsByLocationExpectation{}
	}

	if mmListStockItemsByLocation.defaultExpectation.paramPtrs != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by ExpectParams functions")
	}

	mmListStockItemsByLocation.defaultExpectation.params = &StockServiceRepositoryMockListStockItemsByLocationParams{ctx, filter}
	mmListStockItemsByLocation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListStockItemsByLocation.expectations {
		if minimock.Equal(e.params, mmListStockItemsByLocation.defaultExpectation.params) {
			mmListStockItemsByLocation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListStockItemsByLocation.defaultExpectation.params)
		}
	}

	return mmListStockItemsByLocation
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.ListStockItemsByLocation
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockListStockItemsByLocation {
	if mmListStockItemsByLocation.mock.funcListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Set")
	}

	if mmListStockItemsByLocation.defaultExpectation == nil {
		mmListStockItemsByLocation.defaultExpectation = &StockServiceRepositoryMockListStockItemsByLocationExpectation{}
	}

	if mmListStockItemsByLocation.defaultExpectation.params != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Expect")
	}

	if mmListStockItemsByLocation.defaultExpectation.paramPtrs == nil {
		mmListStockItemsByLocation.defaultExpectation.paramPtrs = &StockServiceRepositoryMockListStockItemsByLocationParamPtrs{}
	}
	mmListStockItemsByLocation.defaultExpectation.paramPtrs.ctx = &ctx
	mmListStockItemsByLocation.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListStockItemsByLocation
}

// ExpectFilterParam2 sets up expected param filter for StockServiceRepository.ListStockItemsByLocation
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) ExpectFilterParam2(filter domain.Filter) *mStockServiceRepositoryMockListStockItemsByLocation {
	if mmListStockItemsByLocation.mock.funcListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Set")
	}

	if mmListStockItemsByLocation.defaultExpectation == nil {
		mmListStockItemsByLocation.defaultExpectation = &StockServiceRepositoryMockListStockItemsByLocationExpectation{}
	}

	if mmListStockItemsByLocation.defaultExpectation.params != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Expect")
	}

	if mmListStockItemsByLocation.defaultExpectation.paramPtrs == nil {
		mmListStockItemsByLocation.defaultExpectation.paramPtrs = &StockServiceRepositoryMockListStockItemsByLocationParamPtrs{}
	}
	mmListStockItemsByLocation.defaultExpectation.paramPtrs.filter = &filter
	mmListStockItemsByLocation.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListStockItemsByLocation
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.ListStockItemsByLocation
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Inspect(f func(ctx context.Context, filter domain.Filter)) *mStockServiceRepositoryMockListStockItemsByLocation {
	if mmListStockItemsByLocation.mock.inspectFuncListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.ListStockItemsByLocation")
	}

	mmListStockItemsByLocation.mock.inspectFuncListStockItemsByLocation = f

	return mmListStockItemsByLocation
}

// Return sets up results that will be returned by StockServiceRepository.ListStockItemsByLocation
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Return(sa1 []domain.StockItem, err error) *StockServiceRepositoryMock {
	if mmListStockItemsByLocation.mock.funcListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Set")
	}

	if mmListStockItemsByLocation.defaultExpectation == nil {
		mmListStockItemsByLocation.defaultExpectation = &StockServiceRepositoryMockListStockItemsByLocationExpectation{mock: mmListStockItemsByLocation.mock}
	}
	mmListStockItemsByLocation.defaultExpectation.results = &StockServiceRepositoryMockListStockItemsByLocationResults{sa1, err}
	mmListStockItemsByLocation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListStockItemsByLocation.mock
}

// Set uses given function f to mock the StockServiceRepository.ListStockItemsByLocation method
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Set(f func(ctx context.Context, filter domain.Filter) (sa1 []domain.StockItem, err error)) *StockServiceRepositoryMock {
	if mmListStockItemsByLocation.defaultExpectation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.ListStockItemsByLocation method")
	}

	if len(mmListStockItemsByLocation.expectations) > 0 {
		mmListStockItemsByLocation.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.ListStockItemsByLocation method")
	}

	mmListStockItemsByLocation.mock.funcListStockItemsByLocation = f
	mmListStockItemsByLocation.mock.funcListStockItemsByLocationOrigin = minimock.CallerInfo(1)
	return mmListStockItemsByLocation.mock
}

// When sets expectation for the StockServiceRepository.ListStockItemsByLocation which will trigger the result defined by the following
// Then helper
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) When(ctx context.Context, filter domain.Filter) *StockServiceRepositoryMockListStockItemsByLocationExpectation {
	if mmListStockItemsByLocation.mock.funcListStockItemsByLocation != nil {
		mmListStockItemsByLocation.mock.t.Fatalf("StockServiceRepositoryMock.ListStockItemsByLocation mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockListStockItemsByLocationExpectation{
		mock:               mmListStockItemsByLocation.mock,
		params:             &StockServiceRepositoryMockListStockItemsByLocationParams{ctx, filter},
		expectationOrigins: StockServiceRepositoryMockListStockItemsByLocationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListStockItemsByLocation.expectations = append(mmListStockItemsByLocation.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.ListStockItemsByLocation return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockListStockItemsByLocationExpectation) Then(sa1 []domain.StockItem, err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockListStockItemsByLocationResults{sa1, err}
	return e.mock
}

// Times sets number of times StockServiceRepository.ListStockItemsByLocation should be invoked
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Times(n uint64) *mStockServiceRepositoryMockListStockItemsByLocation {
	if n == 0 {
		mmListStockItemsByLocation.mock.t.Fatalf("Times of StockServiceRepositoryMock.ListStockItemsByLocation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListStockItemsByLocation.expectedInvocations, n)
	mmListStockItemsByLocation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListStockItemsByLocation
}

func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) invocationsDone() bool {
	if len(mmListStockItemsByLocation.expectations) == 0 && mmListStockItemsByLocation.defaultExpectation == nil && mmListStockItemsByLocation.mock.funcListStockItemsByLocation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListStockItemsByLocation.mock.afterListStockItemsByLocationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListStockItemsByLocation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListStockItemsByLocation implements mm_stocks.StockServiceRepository
func (mmListStockItemsByLocation *StockServiceRepositoryMock) ListStockItemsByLocation(ctx context.Context, filter domain.Filter) (sa1 []domain.StockItem, err error) {
	mm_atomic.AddUint64(&mmListStockItemsByLocation.beforeListStockItemsByLocationCounter, 1)
	defer mm_atomic.AddUint64(&mmListStockItemsByLocation.afterListStockItemsByLocationCounter, 1)

	mmListStockItemsByLocation.t.Helper()

	if mmListStockItemsByLocation.inspectFuncListStockItemsByLocation != nil {
		mmListStockItemsByLocation.inspectFuncListStockItemsByLocation(ctx, filter)
	}

	mm_params := StockServiceRepositoryMockListStockItemsByLocationParams{ctx, filter}

	// Record call args
	mmListStockItemsByLocation.ListStockItemsByLocationMock.mutex.Lock()
	mmListStockItemsByLocation.ListStockItemsByLocationMock.callArgs = append(mmListStockItemsByLocation.ListStockItemsByLocationMock.callArgs, &mm_params)
	mmListStockItemsByLocation.ListStockItemsByLocationMock.mutex.Unlock()

	for _, e := range mmListStockItemsByLocation.ListStockItemsByLocationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.Counter, 1)
		mm_want := mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.params
		mm_want_ptrs := mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockListStockItemsByLocationParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListStockItemsByLocation.t.Errorf("StockServiceRepositoryMock.ListStockItemsByLocation got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListStockItemsByLocation.t.Errorf("StockServiceRepositoryMock.ListStockItemsByLocation got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListStockItemsByLocation.t.Errorf("StockServiceRepositoryMock.ListStockItemsByLocation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListStockItemsByLocation.ListStockItemsByLocationMock.defaultExpectation.results
		if mm_results == nil {
			mmListStockItemsByLocation.t.Fatal("No results are set for the StockServiceRepositoryMock.ListStockItemsByLocation")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListStockItemsByLocation.funcListStockItemsByLocation != nil {
		return mmListStockItemsByLocation.funcListStockItemsByLocation(ctx, filter)
	}
	mmListStockItemsByLocation.t.Fatalf("Unexpected call to StockServiceRepositoryMock.ListStockItemsByLocation. %v %v", ctx, filter)
	return
}

// ListStockItemsByLocationAfterCounter returns a count of finished StockServiceRepositoryMock.ListStockItemsByLocation invocations
func (mmListStockItemsByLocation *StockServiceRepositoryMock) ListStockItemsByLocationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStockItemsByLocation.afterListStockItemsByLocationCounter)
}

// ListStockItemsByLocationBeforeCounter returns a count of StockServiceRepositoryMock.ListStockItemsByLocation invocations
func (mmListStockItemsByLocation *StockServiceRepositoryMock) ListStockItemsByLocationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStockItemsByLocation.beforeListStockItemsByLocationCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.ListStockItemsByLocation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListStockItemsByLocation *mStockServiceRepositoryMockListStockItemsByLocation) Calls() []*StockServiceRepositoryMockListStockItemsByLocationParams {
	mmListStockItemsByLocation.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockListStockItemsByLocationParams, len(mmListStockItemsByLocation.callArgs))
	copy(argCopy, mmListStockItemsByLocation.callArgs)

	mmListStockItemsByLocation.mutex.RUnlock()

	return argCopy
}

// MinimockListStockItemsByLocationDone returns true if the count of the ListStockItemsByLocation invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockListStockItemsByLocationDone() bool {
	if m.ListStockItemsByLocationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListStockItemsByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListStockItemsByLocationMock.invocationsDone()
}

// MinimockListStockItemsByLocationInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockListStockItemsByLocationInspect() {
	for _, e := range m.ListStockItemsByLocationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.ListStockItemsByLocation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListStockItemsByLocationCounter := mm_atomic.LoadUint64(&m.afterListStockItemsByLocationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListStockItemsByLocationMock.defaultExpectation != nil && afterListStockItemsByLocationCounter < 1 {
		if m.ListStockItemsByLocationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.ListStockItemsByLocation at\n%s", m.ListStockItemsByLocationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.ListStockItemsByLocation at\n%s with params: %#v", m.ListStockItemsByLocationMock.defaultExpectation.expectationOrigins.origin, *m.ListStockItemsByLocationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStockItemsByLocation != nil && afterListStockItemsByLocationCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.ListStockItemsByLocation at\n%s", m.funcListStockItemsByLocationOrigin)
	}

	if !m.ListStockItemsByLocationMock.invocationsDone() && afterListStockItemsByLocationCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.ListStockItemsByLocation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListStockItemsByLocationMock.expectedInvocations), m.ListStockItemsByLocationMock.expectedInvocationsOrigin, afterListStockItemsByLocationCounter)
	}
}

type mStockServiceRepositoryMockSaveStockItem struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockSaveStockItemExpectation
	expectations       []*StockServiceRepositoryMockSaveStockItemExpectation

	callArgs []*StockServiceRepositoryMockSaveStockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockSaveStockItemExpectation specifies expectation struct of the StockServiceRepository.SaveStockItem
type StockServiceRepositoryMockSaveStockItemExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockSaveStockItemParams
	paramPtrs          *StockServiceRepositoryMockSaveStockItemParamPtrs
	expectationOrigins StockServiceRepositoryMockSaveStockItemExpectationOrigins
	results            *StockServiceRepositoryMockSaveStockItemResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockSaveStockItemParams contains parameters of the StockServiceRepository.SaveStockItem
type StockServiceRepositoryMockSaveStockItemParams struct {
	ctx       context.Context
	stockItem domain.StockItem
}

// StockServiceRepositoryMockSaveStockItemParamPtrs contains pointers to parameters of the StockServiceRepository.SaveStockItem
type StockServiceRepositoryMockSaveStockItemParamPtrs struct {
	ctx       *context.Context
	stockItem *domain.StockItem
}

// StockServiceRepositoryMockSaveStockItemResults contains results of the StockServiceRepository.SaveStockItem
type StockServiceRepositoryMockSaveStockItemResults struct {
	err error
}

// StockServiceRepositoryMockSaveStockItemOrigins contains origins of expectations of the StockServiceRepository.SaveStockItem
type StockServiceRepositoryMockSaveStockItemExpectationOrigins struct {
	origin          string
	originCtx       string
	originStockItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Optional() *mStockServiceRepositoryMockSaveStockItem {
	mmSaveStockItem.optional = true
	return mmSaveStockItem
}

// Expect sets up expected params for StockServiceRepository.SaveStockItem
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Expect(ctx context.Context, stockItem domain.StockItem) *mStockServiceRepositoryMockSaveStockItem {
	if mmSaveStockItem.mock.funcSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Set")
	}

	if mmSaveStockItem.defaultExpectation == nil {
		mmSaveStockItem.defaultExpectation = &StockServiceRepositoryMockSaveStockItemExpectation{}
	}

	if mmSaveStockItem.defaultExpectation.paramPtrs != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by ExpectParams functions")
	}

	mmSaveStockItem.defaultExpectation.params = &StockServiceRepositoryMockSaveStockItemParams{ctx, stockItem}
	mmSaveStockItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveStockItem.expectations {
		if minimock.Equal(e.params, mmSaveStockItem.defaultExpectation.params) {
			mmSaveStockItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveStockItem.defaultExpectation.params)
		}
	}

	return mmSaveStockItem
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.SaveStockItem
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockSaveStockItem {
	if mmSaveStockItem.mock.funcSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Set")
	}

	if mmSaveStockItem.defaultExpectation == nil {
		mmSaveStockItem.defaultExpectation = &StockServiceRepositoryMockSaveStockItemExpectation{}
	}

	if mmSaveStockItem.defaultExpectation.params != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Expect")
	}

	if mmSaveStockItem.defaultExpectation.paramPtrs == nil {
		mmSaveStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockSaveStockItemParamPtrs{}
	}
	mmSaveStockItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveStockItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveStockItem
}

// ExpectStockItemParam2 sets up expected param stockItem for StockServiceRepository.SaveStockItem
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) ExpectStockItemParam2(stockItem domain.StockItem) *mStockServiceRepositoryMockSaveStockItem {
	if mmSaveStockItem.mock.funcSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Set")
	}

	if mmSaveStockItem.defaultExpectation == nil {
		mmSaveStockItem.defaultExpectation = &StockServiceRepositoryMockSaveStockItemExpectation{}
	}

	if mmSaveStockItem.defaultExpectation.params != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Expect")
	}

	if mmSaveStockItem.defaultExpectation.paramPtrs == nil {
		mmSaveStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockSaveStockItemParamPtrs{}
	}
	mmSaveStockItem.defaultExpectation.paramPtrs.stockItem = &stockItem
	mmSaveStockItem.defaultExpectation.expectationOrigins.originStockItem = minimock.CallerInfo(1)

	return mmSaveStockItem
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.SaveStockItem
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Inspect(f func(ctx context.Context, stockItem domain.StockItem)) *mStockServiceRepositoryMockSaveStockItem {
	if mmSaveStockItem.mock.inspectFuncSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.SaveStockItem")
	}

	mmSaveStockItem.mock.inspectFuncSaveStockItem = f

	return mmSaveStockItem
}

// Return sets up results that will be returned by StockServiceRepository.SaveStockItem
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Return(err error) *StockServiceRepositoryMock {
	if mmSaveStockItem.mock.funcSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Set")
	}

	if mmSaveStockItem.defaultExpectation == nil {
		mmSaveStockItem.defaultExpectation = &StockServiceRepositoryMockSaveStockItemExpectation{mock: mmSaveStockItem.mock}
	}
	mmSaveStockItem.defaultExpectation.results = &StockServiceRepositoryMockSaveStockItemResults{err}
	mmSaveStockItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveStockItem.mock
}

// Set uses given function f to mock the StockServiceRepository.SaveStockItem method
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Set(f func(ctx context.Context, stockItem domain.StockItem) (err error)) *StockServiceRepositoryMock {
	if mmSaveStockItem.defaultExpectation != nil {
		mmSaveStockItem.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.SaveStockItem method")
	}

	if len(mmSaveStockItem.expectations) > 0 {
		mmSaveStockItem.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.SaveStockItem method")
	}

	mmSaveStockItem.mock.funcSaveStockItem = f
	mmSaveStockItem.mock.funcSaveStockItemOrigin = minimock.CallerInfo(1)
	return mmSaveStockItem.mock
}

// When sets expectation for the StockServiceRepository.SaveStockItem which will trigger the result defined by the following
// Then helper
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) When(ctx context.Context, stockItem domain.StockItem) *StockServiceRepositoryMockSaveStockItemExpectation {
	if mmSaveStockItem.mock.funcSaveStockItem != nil {
		mmSaveStockItem.mock.t.Fatalf("StockServiceRepositoryMock.SaveStockItem mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockSaveStockItemExpectation{
		mock:               mmSaveStockItem.mock,
		params:             &StockServiceRepositoryMockSaveStockItemParams{ctx, stockItem},
		expectationOrigins: StockServiceRepositoryMockSaveStockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveStockItem.expectations = append(mmSaveStockItem.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.SaveStockItem return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockSaveStockItemExpectation) Then(err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockSaveStockItemResults{err}
	return e.mock
}

// Times sets number of times StockServiceRepository.SaveStockItem should be invoked
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Times(n uint64) *mStockServiceRepositoryMockSaveStockItem {
	if n == 0 {
		mmSaveStockItem.mock.t.Fatalf("Times of StockServiceRepositoryMock.SaveStockItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveStockItem.expectedInvocations, n)
	mmSaveStockItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveStockItem
}

func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) invocationsDone() bool {
	if len(mmSaveStockItem.expectations) == 0 && mmSaveStockItem.defaultExpectation == nil && mmSaveStockItem.mock.funcSaveStockItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveStockItem.mock.afterSaveStockItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveStockItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveStockItem implements mm_stocks.StockServiceRepository
func (mmSaveStockItem *StockServiceRepositoryMock) SaveStockItem(ctx context.Context, stockItem domain.StockItem) (err error) {
	mm_atomic.AddUint64(&mmSaveStockItem.beforeSaveStockItemCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveStockItem.afterSaveStockItemCounter, 1)

	mmSaveStockItem.t.Helper()

	if mmSaveStockItem.inspectFuncSaveStockItem != nil {
		mmSaveStockItem.inspectFuncSaveStockItem(ctx, stockItem)
	}

	mm_params := StockServiceRepositoryMockSaveStockItemParams{ctx, stockItem}

	// Record call args
	mmSaveStockItem.SaveStockItemMock.mutex.Lock()
	mmSaveStockItem.SaveStockItemMock.callArgs = append(mmSaveStockItem.SaveStockItemMock.callArgs, &mm_params)
	mmSaveStockItem.SaveStockItemMock.mutex.Unlock()

	for _, e := range mmSaveStockItem.SaveStockItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveStockItem.SaveStockItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveStockItem.SaveStockItemMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveStockItem.SaveStockItemMock.defaultExpectation.params
		mm_want_ptrs := mmSaveStockItem.SaveStockItemMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockSaveStockItemParams{ctx, stockItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveStockItem.t.Errorf("StockServiceRepositoryMock.SaveStockItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveStockItem.SaveStockItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stockItem != nil && !minimock.Equal(*mm_want_ptrs.stockItem, mm_got.stockItem) {
				mmSaveStockItem.t.Errorf("StockServiceRepositoryMock.SaveStockItem got unexpected parameter stockItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveStockItem.SaveStockItemMock.defaultExpectation.expectationOrigins.originStockItem, *mm_want_ptrs.stockItem, mm_got.stockItem, minimock.Diff(*mm_want_ptrs.stockItem, mm_got.stockItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveStockItem.t.Errorf("StockServiceRepositoryMock.SaveStockItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveStockItem.SaveStockItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveStockItem.SaveStockItemMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveStockItem.t.Fatal("No results are set for the StockServiceRepositoryMock.SaveStockItem")
		}
		return (*mm_results).err
	}
	if mmSaveStockItem.funcSaveStockItem != nil {
		return mmSaveStockItem.funcSaveStockItem(ctx, stockItem)
	}
	mmSaveStockItem.t.Fatalf("Unexpected call to StockServiceRepositoryMock.SaveStockItem. %v %v", ctx, stockItem)
	return
}

// SaveStockItemAfterCounter returns a count of finished StockServiceRepositoryMock.SaveStockItem invocations
func (mmSaveStockItem *StockServiceRepositoryMock) SaveStockItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveStockItem.afterSaveStockItemCounter)
}

// SaveStockItemBeforeCounter returns a count of StockServiceRepositoryMock.SaveStockItem invocations
func (mmSaveStockItem *StockServiceRepositoryMock) SaveStockItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveStockItem.beforeSaveStockItemCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.SaveStockItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveStockItem *mStockServiceRepositoryMockSaveStockItem) Calls() []*StockServiceRepositoryMockSaveStockItemParams {
	mmSaveStockItem.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockSaveStockItemParams, len(mmSaveStockItem.callArgs))
	copy(argCopy, mmSaveStockItem.callArgs)

	mmSaveStockItem.mutex.RUnlock()

	return argCopy
}

// MinimockSaveStockItemDone returns true if the count of the SaveStockItem invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockSaveStockItemDone() bool {
	if m.SaveStockItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveStockItemMock.invocationsDone()
}

// MinimockSaveStockItemInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockSaveStockItemInspect() {
	for _, e := range m.SaveStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.SaveStockItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveStockItemCounter := mm_atomic.LoadUint64(&m.afterSaveStockItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveStockItemMock.defaultExpectation != nil && afterSaveStockItemCounter < 1 {
		if m.SaveStockItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.SaveStockItem at\n%s", m.SaveStockItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.SaveStockItem at\n%s with params: %#v", m.SaveStockItemMock.defaultExpectation.expectationOrigins.origin, *m.SaveStockItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveStockItem != nil && afterSaveStockItemCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.SaveStockItem at\n%s", m.funcSaveStockItemOrigin)
	}

	if !m.SaveStockItemMock.invocationsDone() && afterSaveStockItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.SaveStockItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveStockItemMock.expectedInvocations), m.SaveStockItemMock.expectedInvocationsOrigin, afterSaveStockItemCounter)
	}
}

type mStockServiceRepositoryMockUpdateStockItem struct {
	optional           bool
	mock               *StockServiceRepositoryMock
	defaultExpectation *StockServiceRepositoryMockUpdateStockItemExpectation
	expectations       []*StockServiceRepositoryMockUpdateStockItemExpectation

	callArgs []*StockServiceRepositoryMockUpdateStockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceRepositoryMockUpdateStockItemExpectation specifies expectation struct of the StockServiceRepository.UpdateStockItem
type StockServiceRepositoryMockUpdateStockItemExpectation struct {
	mock               *StockServiceRepositoryMock
	params             *StockServiceRepositoryMockUpdateStockItemParams
	paramPtrs          *StockServiceRepositoryMockUpdateStockItemParamPtrs
	expectationOrigins StockServiceRepositoryMockUpdateStockItemExpectationOrigins
	results            *StockServiceRepositoryMockUpdateStockItemResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceRepositoryMockUpdateStockItemParams contains parameters of the StockServiceRepository.UpdateStockItem
type StockServiceRepositoryMockUpdateStockItemParams struct {
	ctx       context.Context
	stockItem domain.StockItem
}

// StockServiceRepositoryMockUpdateStockItemParamPtrs contains pointers to parameters of the StockServiceRepository.UpdateStockItem
type StockServiceRepositoryMockUpdateStockItemParamPtrs struct {
	ctx       *context.Context
	stockItem *domain.StockItem
}

// StockServiceRepositoryMockUpdateStockItemResults contains results of the StockServiceRepository.UpdateStockItem
type StockServiceRepositoryMockUpdateStockItemResults struct {
	err error
}

// StockServiceRepositoryMockUpdateStockItemOrigins contains origins of expectations of the StockServiceRepository.UpdateStockItem
type StockServiceRepositoryMockUpdateStockItemExpectationOrigins struct {
	origin          string
	originCtx       string
	originStockItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Optional() *mStockServiceRepositoryMockUpdateStockItem {
	mmUpdateStockItem.optional = true
	return mmUpdateStockItem
}

// Expect sets up expected params for StockServiceRepository.UpdateStockItem
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Expect(ctx context.Context, stockItem domain.StockItem) *mStockServiceRepositoryMockUpdateStockItem {
	if mmUpdateStockItem.mock.funcUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Set")
	}

	if mmUpdateStockItem.defaultExpectation == nil {
		mmUpdateStockItem.defaultExpectation = &StockServiceRepositoryMockUpdateStockItemExpectation{}
	}

	if mmUpdateStockItem.defaultExpectation.paramPtrs != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by ExpectParams functions")
	}

	mmUpdateStockItem.defaultExpectation.params = &StockServiceRepositoryMockUpdateStockItemParams{ctx, stockItem}
	mmUpdateStockItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateStockItem.expectations {
		if minimock.Equal(e.params, mmUpdateStockItem.defaultExpectation.params) {
			mmUpdateStockItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStockItem.defaultExpectation.params)
		}
	}

	return mmUpdateStockItem
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceRepository.UpdateStockItem
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) ExpectCtxParam1(ctx context.Context) *mStockServiceRepositoryMockUpdateStockItem {
	if mmUpdateStockItem.mock.funcUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Set")
	}

	if mmUpdateStockItem.defaultExpectation == nil {
		mmUpdateStockItem.defaultExpectation = &StockServiceRepositoryMockUpdateStockItemExpectation{}
	}

	if mmUpdateStockItem.defaultExpectation.params != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Expect")
	}

	if mmUpdateStockItem.defaultExpectation.paramPtrs == nil {
		mmUpdateStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockUpdateStockItemParamPtrs{}
	}
	mmUpdateStockItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateStockItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateStockItem
}

// ExpectStockItemParam2 sets up expected param stockItem for StockServiceRepository.UpdateStockItem
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) ExpectStockItemParam2(stockItem domain.StockItem) *mStockServiceRepositoryMockUpdateStockItem {
	if mmUpdateStockItem.mock.funcUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Set")
	}

	if mmUpdateStockItem.defaultExpectation == nil {
		mmUpdateStockItem.defaultExpectation = &StockServiceRepositoryMockUpdateStockItemExpectation{}
	}

	if mmUpdateStockItem.defaultExpectation.params != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Expect")
	}

	if mmUpdateStockItem.defaultExpectation.paramPtrs == nil {
		mmUpdateStockItem.defaultExpectation.paramPtrs = &StockServiceRepositoryMockUpdateStockItemParamPtrs{}
	}
	mmUpdateStockItem.defaultExpectation.paramPtrs.stockItem = &stockItem
	mmUpdateStockItem.defaultExpectation.expectationOrigins.originStockItem = minimock.CallerInfo(1)

	return mmUpdateStockItem
}

// Inspect accepts an inspector function that has same arguments as the StockServiceRepository.UpdateStockItem
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Inspect(f func(ctx context.Context, stockItem domain.StockItem)) *mStockServiceRepositoryMockUpdateStockItem {
	if mmUpdateStockItem.mock.inspectFuncUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("Inspect function is already set for StockServiceRepositoryMock.UpdateStockItem")
	}

	mmUpdateStockItem.mock.inspectFuncUpdateStockItem = f

	return mmUpdateStockItem
}

// Return sets up results that will be returned by StockServiceRepository.UpdateStockItem
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Return(err error) *StockServiceRepositoryMock {
	if mmUpdateStockItem.mock.funcUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Set")
	}

	if mmUpdateStockItem.defaultExpectation == nil {
		mmUpdateStockItem.defaultExpectation = &StockServiceRepositoryMockUpdateStockItemExpectation{mock: mmUpdateStockItem.mock}
	}
	mmUpdateStockItem.defaultExpectation.results = &StockServiceRepositoryMockUpdateStockItemResults{err}
	mmUpdateStockItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateStockItem.mock
}

// Set uses given function f to mock the StockServiceRepository.UpdateStockItem method
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Set(f func(ctx context.Context, stockItem domain.StockItem) (err error)) *StockServiceRepositoryMock {
	if mmUpdateStockItem.defaultExpectation != nil {
		mmUpdateStockItem.mock.t.Fatalf("Default expectation is already set for the StockServiceRepository.UpdateStockItem method")
	}

	if len(mmUpdateStockItem.expectations) > 0 {
		mmUpdateStockItem.mock.t.Fatalf("Some expectations are already set for the StockServiceRepository.UpdateStockItem method")
	}

	mmUpdateStockItem.mock.funcUpdateStockItem = f
	mmUpdateStockItem.mock.funcUpdateStockItemOrigin = minimock.CallerInfo(1)
	return mmUpdateStockItem.mock
}

// When sets expectation for the StockServiceRepository.UpdateStockItem which will trigger the result defined by the following
// Then helper
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) When(ctx context.Context, stockItem domain.StockItem) *StockServiceRepositoryMockUpdateStockItemExpectation {
	if mmUpdateStockItem.mock.funcUpdateStockItem != nil {
		mmUpdateStockItem.mock.t.Fatalf("StockServiceRepositoryMock.UpdateStockItem mock is already set by Set")
	}

	expectation := &StockServiceRepositoryMockUpdateStockItemExpectation{
		mock:               mmUpdateStockItem.mock,
		params:             &StockServiceRepositoryMockUpdateStockItemParams{ctx, stockItem},
		expectationOrigins: StockServiceRepositoryMockUpdateStockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateStockItem.expectations = append(mmUpdateStockItem.expectations, expectation)
	return expectation
}

// Then sets up StockServiceRepository.UpdateStockItem return parameters for the expectation previously defined by the When method
func (e *StockServiceRepositoryMockUpdateStockItemExpectation) Then(err error) *StockServiceRepositoryMock {
	e.results = &StockServiceRepositoryMockUpdateStockItemResults{err}
	return e.mock
}

// Times sets number of times StockServiceRepository.UpdateStockItem should be invoked
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Times(n uint64) *mStockServiceRepositoryMockUpdateStockItem {
	if n == 0 {
		mmUpdateStockItem.mock.t.Fatalf("Times of StockServiceRepositoryMock.UpdateStockItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateStockItem.expectedInvocations, n)
	mmUpdateStockItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateStockItem
}

func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) invocationsDone() bool {
	if len(mmUpdateStockItem.expectations) == 0 && mmUpdateStockItem.defaultExpectation == nil && mmUpdateStockItem.mock.funcUpdateStockItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateStockItem.mock.afterUpdateStockItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateStockItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateStockItem implements mm_stocks.StockServiceRepository
func (mmUpdateStockItem *StockServiceRepositoryMock) UpdateStockItem(ctx context.Context, stockItem domain.StockItem) (err error) {
	mm_atomic.AddUint64(&mmUpdateStockItem.beforeUpdateStockItemCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStockItem.afterUpdateStockItemCounter, 1)

	mmUpdateStockItem.t.Helper()

	if mmUpdateStockItem.inspectFuncUpdateStockItem != nil {
		mmUpdateStockItem.inspectFuncUpdateStockItem(ctx, stockItem)
	}

	mm_params := StockServiceRepositoryMockUpdateStockItemParams{ctx, stockItem}

	// Record call args
	mmUpdateStockItem.UpdateStockItemMock.mutex.Lock()
	mmUpdateStockItem.UpdateStockItemMock.callArgs = append(mmUpdateStockItem.UpdateStockItemMock.callArgs, &mm_params)
	mmUpdateStockItem.UpdateStockItemMock.mutex.Unlock()

	for _, e := range mmUpdateStockItem.UpdateStockItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStockItem.UpdateStockItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.paramPtrs

		mm_got := StockServiceRepositoryMockUpdateStockItemParams{ctx, stockItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateStockItem.t.Errorf("StockServiceRepositoryMock.UpdateStockItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stockItem != nil && !minimock.Equal(*mm_want_ptrs.stockItem, mm_got.stockItem) {
				mmUpdateStockItem.t.Errorf("StockServiceRepositoryMock.UpdateStockItem got unexpected parameter stockItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.expectationOrigins.originStockItem, *mm_want_ptrs.stockItem, mm_got.stockItem, minimock.Diff(*mm_want_ptrs.stockItem, mm_got.stockItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStockItem.t.Errorf("StockServiceRepositoryMock.UpdateStockItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStockItem.UpdateStockItemMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStockItem.t.Fatal("No results are set for the StockServiceRepositoryMock.UpdateStockItem")
		}
		return (*mm_results).err
	}
	if mmUpdateStockItem.funcUpdateStockItem != nil {
		return mmUpdateStockItem.funcUpdateStockItem(ctx, stockItem)
	}
	mmUpdateStockItem.t.Fatalf("Unexpected call to StockServiceRepositoryMock.UpdateStockItem. %v %v", ctx, stockItem)
	return
}

// UpdateStockItemAfterCounter returns a count of finished StockServiceRepositoryMock.UpdateStockItem invocations
func (mmUpdateStockItem *StockServiceRepositoryMock) UpdateStockItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStockItem.afterUpdateStockItemCounter)
}

// UpdateStockItemBeforeCounter returns a count of StockServiceRepositoryMock.UpdateStockItem invocations
func (mmUpdateStockItem *StockServiceRepositoryMock) UpdateStockItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStockItem.beforeUpdateStockItemCounter)
}

// Calls returns a list of arguments used in each call to StockServiceRepositoryMock.UpdateStockItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStockItem *mStockServiceRepositoryMockUpdateStockItem) Calls() []*StockServiceRepositoryMockUpdateStockItemParams {
	mmUpdateStockItem.mutex.RLock()

	argCopy := make([]*StockServiceRepositoryMockUpdateStockItemParams, len(mmUpdateStockItem.callArgs))
	copy(argCopy, mmUpdateStockItem.callArgs)

	mmUpdateStockItem.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStockItemDone returns true if the count of the UpdateStockItem invocations corresponds
// the number of defined expectations
func (m *StockServiceRepositoryMock) MinimockUpdateStockItemDone() bool {
	if m.UpdateStockItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateStockItemMock.invocationsDone()
}

// MinimockUpdateStockItemInspect logs each unmet expectation
func (m *StockServiceRepositoryMock) MinimockUpdateStockItemInspect() {
	for _, e := range m.UpdateStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.UpdateStockItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateStockItemCounter := mm_atomic.LoadUint64(&m.afterUpdateStockItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStockItemMock.defaultExpectation != nil && afterUpdateStockItemCounter < 1 {
		if m.UpdateStockItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.UpdateStockItem at\n%s", m.UpdateStockItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceRepositoryMock.UpdateStockItem at\n%s with params: %#v", m.UpdateStockItemMock.defaultExpectation.expectationOrigins.origin, *m.UpdateStockItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStockItem != nil && afterUpdateStockItemCounter < 1 {
		m.t.Errorf("Expected call to StockServiceRepositoryMock.UpdateStockItem at\n%s", m.funcUpdateStockItemOrigin)
	}

	if !m.UpdateStockItemMock.invocationsDone() && afterUpdateStockItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceRepositoryMock.UpdateStockItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateStockItemMock.expectedInvocations), m.UpdateStockItemMock.expectedInvocationsOrigin, afterUpdateStockItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockServiceRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCountStockItemsInspect()

			m.MinimockDeleteStockItemFromStorageInspect()

			m.MinimockGetStockItemInspect()

			m.MinimockGetStockItemBySkuInspect()

			m.MinimockListStockItemsByLocationInspect()

			m.MinimockSaveStockItemInspect()

			m.MinimockUpdateStockItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockServiceRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockServiceRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCountStockItemsDone() &&
		m.MinimockDeleteStockItemFromStorageDone() &&
		m.MinimockGetStockItemDone() &&
		m.MinimockGetStockItemBySkuDone() &&
		m.MinimockListStockItemsByLocationDone() &&
		m.MinimockSaveStockItemDone() &&
		m.MinimockUpdateStockItemDone()
}
