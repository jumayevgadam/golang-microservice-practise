// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"stocks/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockServiceUseCaseMock implements mm_usecase.StockServiceUseCase
type StockServiceUseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddStockItem          func(ctx context.Context, stockItem domain.StockItem) (err error)
	funcAddStockItemOrigin    string
	inspectFuncAddStockItem   func(ctx context.Context, stockItem domain.StockItem)
	afterAddStockItemCounter  uint64
	beforeAddStockItemCounter uint64
	AddStockItemMock          mStockServiceUseCaseMockAddStockItem

	funcDeleteStockItem          func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error)
	funcDeleteStockItemOrigin    string
	inspectFuncDeleteStockItem   func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)
	afterDeleteStockItemCounter  uint64
	beforeDeleteStockItemCounter uint64
	DeleteStockItemMock          mStockServiceUseCaseMockDeleteStockItem

	funcGetStockItemBySKU          func(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error)
	funcGetStockItemBySKUOrigin    string
	inspectFuncGetStockItemBySKU   func(ctx context.Context, skuID domain.SKUID)
	afterGetStockItemBySKUCounter  uint64
	beforeGetStockItemBySKUCounter uint64
	GetStockItemBySKUMock          mStockServiceUseCaseMockGetStockItemBySKU

	funcListStockItems          func(ctx context.Context, filter domain.Filter) (p1 domain.PaginatedResponse[domain.StockItem], err error)
	funcListStockItemsOrigin    string
	inspectFuncListStockItems   func(ctx context.Context, filter domain.Filter)
	afterListStockItemsCounter  uint64
	beforeListStockItemsCounter uint64
	ListStockItemsMock          mStockServiceUseCaseMockListStockItems
}

// NewStockServiceUseCaseMock returns a mock for mm_usecase.StockServiceUseCase
func NewStockServiceUseCaseMock(t minimock.Tester) *StockServiceUseCaseMock {
	m := &StockServiceUseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddStockItemMock = mStockServiceUseCaseMockAddStockItem{mock: m}
	m.AddStockItemMock.callArgs = []*StockServiceUseCaseMockAddStockItemParams{}

	m.DeleteStockItemMock = mStockServiceUseCaseMockDeleteStockItem{mock: m}
	m.DeleteStockItemMock.callArgs = []*StockServiceUseCaseMockDeleteStockItemParams{}

	m.GetStockItemBySKUMock = mStockServiceUseCaseMockGetStockItemBySKU{mock: m}
	m.GetStockItemBySKUMock.callArgs = []*StockServiceUseCaseMockGetStockItemBySKUParams{}

	m.ListStockItemsMock = mStockServiceUseCaseMockListStockItems{mock: m}
	m.ListStockItemsMock.callArgs = []*StockServiceUseCaseMockListStockItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockServiceUseCaseMockAddStockItem struct {
	optional           bool
	mock               *StockServiceUseCaseMock
	defaultExpectation *StockServiceUseCaseMockAddStockItemExpectation
	expectations       []*StockServiceUseCaseMockAddStockItemExpectation

	callArgs []*StockServiceUseCaseMockAddStockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceUseCaseMockAddStockItemExpectation specifies expectation struct of the StockServiceUseCase.AddStockItem
type StockServiceUseCaseMockAddStockItemExpectation struct {
	mock               *StockServiceUseCaseMock
	params             *StockServiceUseCaseMockAddStockItemParams
	paramPtrs          *StockServiceUseCaseMockAddStockItemParamPtrs
	expectationOrigins StockServiceUseCaseMockAddStockItemExpectationOrigins
	results            *StockServiceUseCaseMockAddStockItemResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceUseCaseMockAddStockItemParams contains parameters of the StockServiceUseCase.AddStockItem
type StockServiceUseCaseMockAddStockItemParams struct {
	ctx       context.Context
	stockItem domain.StockItem
}

// StockServiceUseCaseMockAddStockItemParamPtrs contains pointers to parameters of the StockServiceUseCase.AddStockItem
type StockServiceUseCaseMockAddStockItemParamPtrs struct {
	ctx       *context.Context
	stockItem *domain.StockItem
}

// StockServiceUseCaseMockAddStockItemResults contains results of the StockServiceUseCase.AddStockItem
type StockServiceUseCaseMockAddStockItemResults struct {
	err error
}

// StockServiceUseCaseMockAddStockItemOrigins contains origins of expectations of the StockServiceUseCase.AddStockItem
type StockServiceUseCaseMockAddStockItemExpectationOrigins struct {
	origin          string
	originCtx       string
	originStockItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Optional() *mStockServiceUseCaseMockAddStockItem {
	mmAddStockItem.optional = true
	return mmAddStockItem
}

// Expect sets up expected params for StockServiceUseCase.AddStockItem
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Expect(ctx context.Context, stockItem domain.StockItem) *mStockServiceUseCaseMockAddStockItem {
	if mmAddStockItem.mock.funcAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Set")
	}

	if mmAddStockItem.defaultExpectation == nil {
		mmAddStockItem.defaultExpectation = &StockServiceUseCaseMockAddStockItemExpectation{}
	}

	if mmAddStockItem.defaultExpectation.paramPtrs != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by ExpectParams functions")
	}

	mmAddStockItem.defaultExpectation.params = &StockServiceUseCaseMockAddStockItemParams{ctx, stockItem}
	mmAddStockItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddStockItem.expectations {
		if minimock.Equal(e.params, mmAddStockItem.defaultExpectation.params) {
			mmAddStockItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddStockItem.defaultExpectation.params)
		}
	}

	return mmAddStockItem
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceUseCase.AddStockItem
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) ExpectCtxParam1(ctx context.Context) *mStockServiceUseCaseMockAddStockItem {
	if mmAddStockItem.mock.funcAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Set")
	}

	if mmAddStockItem.defaultExpectation == nil {
		mmAddStockItem.defaultExpectation = &StockServiceUseCaseMockAddStockItemExpectation{}
	}

	if mmAddStockItem.defaultExpectation.params != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Expect")
	}

	if mmAddStockItem.defaultExpectation.paramPtrs == nil {
		mmAddStockItem.defaultExpectation.paramPtrs = &StockServiceUseCaseMockAddStockItemParamPtrs{}
	}
	mmAddStockItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddStockItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddStockItem
}

// ExpectStockItemParam2 sets up expected param stockItem for StockServiceUseCase.AddStockItem
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) ExpectStockItemParam2(stockItem domain.StockItem) *mStockServiceUseCaseMockAddStockItem {
	if mmAddStockItem.mock.funcAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Set")
	}

	if mmAddStockItem.defaultExpectation == nil {
		mmAddStockItem.defaultExpectation = &StockServiceUseCaseMockAddStockItemExpectation{}
	}

	if mmAddStockItem.defaultExpectation.params != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Expect")
	}

	if mmAddStockItem.defaultExpectation.paramPtrs == nil {
		mmAddStockItem.defaultExpectation.paramPtrs = &StockServiceUseCaseMockAddStockItemParamPtrs{}
	}
	mmAddStockItem.defaultExpectation.paramPtrs.stockItem = &stockItem
	mmAddStockItem.defaultExpectation.expectationOrigins.originStockItem = minimock.CallerInfo(1)

	return mmAddStockItem
}

// Inspect accepts an inspector function that has same arguments as the StockServiceUseCase.AddStockItem
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Inspect(f func(ctx context.Context, stockItem domain.StockItem)) *mStockServiceUseCaseMockAddStockItem {
	if mmAddStockItem.mock.inspectFuncAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("Inspect function is already set for StockServiceUseCaseMock.AddStockItem")
	}

	mmAddStockItem.mock.inspectFuncAddStockItem = f

	return mmAddStockItem
}

// Return sets up results that will be returned by StockServiceUseCase.AddStockItem
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Return(err error) *StockServiceUseCaseMock {
	if mmAddStockItem.mock.funcAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Set")
	}

	if mmAddStockItem.defaultExpectation == nil {
		mmAddStockItem.defaultExpectation = &StockServiceUseCaseMockAddStockItemExpectation{mock: mmAddStockItem.mock}
	}
	mmAddStockItem.defaultExpectation.results = &StockServiceUseCaseMockAddStockItemResults{err}
	mmAddStockItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddStockItem.mock
}

// Set uses given function f to mock the StockServiceUseCase.AddStockItem method
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Set(f func(ctx context.Context, stockItem domain.StockItem) (err error)) *StockServiceUseCaseMock {
	if mmAddStockItem.defaultExpectation != nil {
		mmAddStockItem.mock.t.Fatalf("Default expectation is already set for the StockServiceUseCase.AddStockItem method")
	}

	if len(mmAddStockItem.expectations) > 0 {
		mmAddStockItem.mock.t.Fatalf("Some expectations are already set for the StockServiceUseCase.AddStockItem method")
	}

	mmAddStockItem.mock.funcAddStockItem = f
	mmAddStockItem.mock.funcAddStockItemOrigin = minimock.CallerInfo(1)
	return mmAddStockItem.mock
}

// When sets expectation for the StockServiceUseCase.AddStockItem which will trigger the result defined by the following
// Then helper
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) When(ctx context.Context, stockItem domain.StockItem) *StockServiceUseCaseMockAddStockItemExpectation {
	if mmAddStockItem.mock.funcAddStockItem != nil {
		mmAddStockItem.mock.t.Fatalf("StockServiceUseCaseMock.AddStockItem mock is already set by Set")
	}

	expectation := &StockServiceUseCaseMockAddStockItemExpectation{
		mock:               mmAddStockItem.mock,
		params:             &StockServiceUseCaseMockAddStockItemParams{ctx, stockItem},
		expectationOrigins: StockServiceUseCaseMockAddStockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddStockItem.expectations = append(mmAddStockItem.expectations, expectation)
	return expectation
}

// Then sets up StockServiceUseCase.AddStockItem return parameters for the expectation previously defined by the When method
func (e *StockServiceUseCaseMockAddStockItemExpectation) Then(err error) *StockServiceUseCaseMock {
	e.results = &StockServiceUseCaseMockAddStockItemResults{err}
	return e.mock
}

// Times sets number of times StockServiceUseCase.AddStockItem should be invoked
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Times(n uint64) *mStockServiceUseCaseMockAddStockItem {
	if n == 0 {
		mmAddStockItem.mock.t.Fatalf("Times of StockServiceUseCaseMock.AddStockItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddStockItem.expectedInvocations, n)
	mmAddStockItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddStockItem
}

func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) invocationsDone() bool {
	if len(mmAddStockItem.expectations) == 0 && mmAddStockItem.defaultExpectation == nil && mmAddStockItem.mock.funcAddStockItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddStockItem.mock.afterAddStockItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddStockItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddStockItem implements mm_usecase.StockServiceUseCase
func (mmAddStockItem *StockServiceUseCaseMock) AddStockItem(ctx context.Context, stockItem domain.StockItem) (err error) {
	mm_atomic.AddUint64(&mmAddStockItem.beforeAddStockItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddStockItem.afterAddStockItemCounter, 1)

	mmAddStockItem.t.Helper()

	if mmAddStockItem.inspectFuncAddStockItem != nil {
		mmAddStockItem.inspectFuncAddStockItem(ctx, stockItem)
	}

	mm_params := StockServiceUseCaseMockAddStockItemParams{ctx, stockItem}

	// Record call args
	mmAddStockItem.AddStockItemMock.mutex.Lock()
	mmAddStockItem.AddStockItemMock.callArgs = append(mmAddStockItem.AddStockItemMock.callArgs, &mm_params)
	mmAddStockItem.AddStockItemMock.mutex.Unlock()

	for _, e := range mmAddStockItem.AddStockItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddStockItem.AddStockItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddStockItem.AddStockItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddStockItem.AddStockItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddStockItem.AddStockItemMock.defaultExpectation.paramPtrs

		mm_got := StockServiceUseCaseMockAddStockItemParams{ctx, stockItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddStockItem.t.Errorf("StockServiceUseCaseMock.AddStockItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStockItem.AddStockItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.stockItem != nil && !minimock.Equal(*mm_want_ptrs.stockItem, mm_got.stockItem) {
				mmAddStockItem.t.Errorf("StockServiceUseCaseMock.AddStockItem got unexpected parameter stockItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddStockItem.AddStockItemMock.defaultExpectation.expectationOrigins.originStockItem, *mm_want_ptrs.stockItem, mm_got.stockItem, minimock.Diff(*mm_want_ptrs.stockItem, mm_got.stockItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddStockItem.t.Errorf("StockServiceUseCaseMock.AddStockItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddStockItem.AddStockItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddStockItem.AddStockItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddStockItem.t.Fatal("No results are set for the StockServiceUseCaseMock.AddStockItem")
		}
		return (*mm_results).err
	}
	if mmAddStockItem.funcAddStockItem != nil {
		return mmAddStockItem.funcAddStockItem(ctx, stockItem)
	}
	mmAddStockItem.t.Fatalf("Unexpected call to StockServiceUseCaseMock.AddStockItem. %v %v", ctx, stockItem)
	return
}

// AddStockItemAfterCounter returns a count of finished StockServiceUseCaseMock.AddStockItem invocations
func (mmAddStockItem *StockServiceUseCaseMock) AddStockItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStockItem.afterAddStockItemCounter)
}

// AddStockItemBeforeCounter returns a count of StockServiceUseCaseMock.AddStockItem invocations
func (mmAddStockItem *StockServiceUseCaseMock) AddStockItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddStockItem.beforeAddStockItemCounter)
}

// Calls returns a list of arguments used in each call to StockServiceUseCaseMock.AddStockItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddStockItem *mStockServiceUseCaseMockAddStockItem) Calls() []*StockServiceUseCaseMockAddStockItemParams {
	mmAddStockItem.mutex.RLock()

	argCopy := make([]*StockServiceUseCaseMockAddStockItemParams, len(mmAddStockItem.callArgs))
	copy(argCopy, mmAddStockItem.callArgs)

	mmAddStockItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddStockItemDone returns true if the count of the AddStockItem invocations corresponds
// the number of defined expectations
func (m *StockServiceUseCaseMock) MinimockAddStockItemDone() bool {
	if m.AddStockItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddStockItemMock.invocationsDone()
}

// MinimockAddStockItemInspect logs each unmet expectation
func (m *StockServiceUseCaseMock) MinimockAddStockItemInspect() {
	for _, e := range m.AddStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.AddStockItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddStockItemCounter := mm_atomic.LoadUint64(&m.afterAddStockItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddStockItemMock.defaultExpectation != nil && afterAddStockItemCounter < 1 {
		if m.AddStockItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.AddStockItem at\n%s", m.AddStockItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.AddStockItem at\n%s with params: %#v", m.AddStockItemMock.defaultExpectation.expectationOrigins.origin, *m.AddStockItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddStockItem != nil && afterAddStockItemCounter < 1 {
		m.t.Errorf("Expected call to StockServiceUseCaseMock.AddStockItem at\n%s", m.funcAddStockItemOrigin)
	}

	if !m.AddStockItemMock.invocationsDone() && afterAddStockItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceUseCaseMock.AddStockItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddStockItemMock.expectedInvocations), m.AddStockItemMock.expectedInvocationsOrigin, afterAddStockItemCounter)
	}
}

type mStockServiceUseCaseMockDeleteStockItem struct {
	optional           bool
	mock               *StockServiceUseCaseMock
	defaultExpectation *StockServiceUseCaseMockDeleteStockItemExpectation
	expectations       []*StockServiceUseCaseMockDeleteStockItemExpectation

	callArgs []*StockServiceUseCaseMockDeleteStockItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceUseCaseMockDeleteStockItemExpectation specifies expectation struct of the StockServiceUseCase.DeleteStockItem
type StockServiceUseCaseMockDeleteStockItemExpectation struct {
	mock               *StockServiceUseCaseMock
	params             *StockServiceUseCaseMockDeleteStockItemParams
	paramPtrs          *StockServiceUseCaseMockDeleteStockItemParamPtrs
	expectationOrigins StockServiceUseCaseMockDeleteStockItemExpectationOrigins
	results            *StockServiceUseCaseMockDeleteStockItemResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceUseCaseMockDeleteStockItemParams contains parameters of the StockServiceUseCase.DeleteStockItem
type StockServiceUseCaseMockDeleteStockItemParams struct {
	ctx    context.Context
	userID domain.UserID
	skuID  domain.SKUID
}

// StockServiceUseCaseMockDeleteStockItemParamPtrs contains pointers to parameters of the StockServiceUseCase.DeleteStockItem
type StockServiceUseCaseMockDeleteStockItemParamPtrs struct {
	ctx    *context.Context
	userID *domain.UserID
	skuID  *domain.SKUID
}

// StockServiceUseCaseMockDeleteStockItemResults contains results of the StockServiceUseCase.DeleteStockItem
type StockServiceUseCaseMockDeleteStockItemResults struct {
	err error
}

// StockServiceUseCaseMockDeleteStockItemOrigins contains origins of expectations of the StockServiceUseCase.DeleteStockItem
type StockServiceUseCaseMockDeleteStockItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Optional() *mStockServiceUseCaseMockDeleteStockItem {
	mmDeleteStockItem.optional = true
	return mmDeleteStockItem
}

// Expect sets up expected params for StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Expect(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *mStockServiceUseCaseMockDeleteStockItem {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	if mmDeleteStockItem.defaultExpectation == nil {
		mmDeleteStockItem.defaultExpectation = &StockServiceUseCaseMockDeleteStockItemExpectation{}
	}

	if mmDeleteStockItem.defaultExpectation.paramPtrs != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by ExpectParams functions")
	}

	mmDeleteStockItem.defaultExpectation.params = &StockServiceUseCaseMockDeleteStockItemParams{ctx, userID, skuID}
	mmDeleteStockItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteStockItem.expectations {
		if minimock.Equal(e.params, mmDeleteStockItem.defaultExpectation.params) {
			mmDeleteStockItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteStockItem.defaultExpectation.params)
		}
	}

	return mmDeleteStockItem
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) ExpectCtxParam1(ctx context.Context) *mStockServiceUseCaseMockDeleteStockItem {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	if mmDeleteStockItem.defaultExpectation == nil {
		mmDeleteStockItem.defaultExpectation = &StockServiceUseCaseMockDeleteStockItemExpectation{}
	}

	if mmDeleteStockItem.defaultExpectation.params != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Expect")
	}

	if mmDeleteStockItem.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItem.defaultExpectation.paramPtrs = &StockServiceUseCaseMockDeleteStockItemParamPtrs{}
	}
	mmDeleteStockItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteStockItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteStockItem
}

// ExpectUserIDParam2 sets up expected param userID for StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) ExpectUserIDParam2(userID domain.UserID) *mStockServiceUseCaseMockDeleteStockItem {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	if mmDeleteStockItem.defaultExpectation == nil {
		mmDeleteStockItem.defaultExpectation = &StockServiceUseCaseMockDeleteStockItemExpectation{}
	}

	if mmDeleteStockItem.defaultExpectation.params != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Expect")
	}

	if mmDeleteStockItem.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItem.defaultExpectation.paramPtrs = &StockServiceUseCaseMockDeleteStockItemParamPtrs{}
	}
	mmDeleteStockItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteStockItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteStockItem
}

// ExpectSkuIDParam3 sets up expected param skuID for StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) ExpectSkuIDParam3(skuID domain.SKUID) *mStockServiceUseCaseMockDeleteStockItem {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	if mmDeleteStockItem.defaultExpectation == nil {
		mmDeleteStockItem.defaultExpectation = &StockServiceUseCaseMockDeleteStockItemExpectation{}
	}

	if mmDeleteStockItem.defaultExpectation.params != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Expect")
	}

	if mmDeleteStockItem.defaultExpectation.paramPtrs == nil {
		mmDeleteStockItem.defaultExpectation.paramPtrs = &StockServiceUseCaseMockDeleteStockItemParamPtrs{}
	}
	mmDeleteStockItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteStockItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteStockItem
}

// Inspect accepts an inspector function that has same arguments as the StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Inspect(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID)) *mStockServiceUseCaseMockDeleteStockItem {
	if mmDeleteStockItem.mock.inspectFuncDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("Inspect function is already set for StockServiceUseCaseMock.DeleteStockItem")
	}

	mmDeleteStockItem.mock.inspectFuncDeleteStockItem = f

	return mmDeleteStockItem
}

// Return sets up results that will be returned by StockServiceUseCase.DeleteStockItem
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Return(err error) *StockServiceUseCaseMock {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	if mmDeleteStockItem.defaultExpectation == nil {
		mmDeleteStockItem.defaultExpectation = &StockServiceUseCaseMockDeleteStockItemExpectation{mock: mmDeleteStockItem.mock}
	}
	mmDeleteStockItem.defaultExpectation.results = &StockServiceUseCaseMockDeleteStockItemResults{err}
	mmDeleteStockItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItem.mock
}

// Set uses given function f to mock the StockServiceUseCase.DeleteStockItem method
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Set(f func(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error)) *StockServiceUseCaseMock {
	if mmDeleteStockItem.defaultExpectation != nil {
		mmDeleteStockItem.mock.t.Fatalf("Default expectation is already set for the StockServiceUseCase.DeleteStockItem method")
	}

	if len(mmDeleteStockItem.expectations) > 0 {
		mmDeleteStockItem.mock.t.Fatalf("Some expectations are already set for the StockServiceUseCase.DeleteStockItem method")
	}

	mmDeleteStockItem.mock.funcDeleteStockItem = f
	mmDeleteStockItem.mock.funcDeleteStockItemOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItem.mock
}

// When sets expectation for the StockServiceUseCase.DeleteStockItem which will trigger the result defined by the following
// Then helper
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) When(ctx context.Context, userID domain.UserID, skuID domain.SKUID) *StockServiceUseCaseMockDeleteStockItemExpectation {
	if mmDeleteStockItem.mock.funcDeleteStockItem != nil {
		mmDeleteStockItem.mock.t.Fatalf("StockServiceUseCaseMock.DeleteStockItem mock is already set by Set")
	}

	expectation := &StockServiceUseCaseMockDeleteStockItemExpectation{
		mock:               mmDeleteStockItem.mock,
		params:             &StockServiceUseCaseMockDeleteStockItemParams{ctx, userID, skuID},
		expectationOrigins: StockServiceUseCaseMockDeleteStockItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteStockItem.expectations = append(mmDeleteStockItem.expectations, expectation)
	return expectation
}

// Then sets up StockServiceUseCase.DeleteStockItem return parameters for the expectation previously defined by the When method
func (e *StockServiceUseCaseMockDeleteStockItemExpectation) Then(err error) *StockServiceUseCaseMock {
	e.results = &StockServiceUseCaseMockDeleteStockItemResults{err}
	return e.mock
}

// Times sets number of times StockServiceUseCase.DeleteStockItem should be invoked
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Times(n uint64) *mStockServiceUseCaseMockDeleteStockItem {
	if n == 0 {
		mmDeleteStockItem.mock.t.Fatalf("Times of StockServiceUseCaseMock.DeleteStockItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteStockItem.expectedInvocations, n)
	mmDeleteStockItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteStockItem
}

func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) invocationsDone() bool {
	if len(mmDeleteStockItem.expectations) == 0 && mmDeleteStockItem.defaultExpectation == nil && mmDeleteStockItem.mock.funcDeleteStockItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteStockItem.mock.afterDeleteStockItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteStockItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteStockItem implements mm_usecase.StockServiceUseCase
func (mmDeleteStockItem *StockServiceUseCaseMock) DeleteStockItem(ctx context.Context, userID domain.UserID, skuID domain.SKUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteStockItem.beforeDeleteStockItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteStockItem.afterDeleteStockItemCounter, 1)

	mmDeleteStockItem.t.Helper()

	if mmDeleteStockItem.inspectFuncDeleteStockItem != nil {
		mmDeleteStockItem.inspectFuncDeleteStockItem(ctx, userID, skuID)
	}

	mm_params := StockServiceUseCaseMockDeleteStockItemParams{ctx, userID, skuID}

	// Record call args
	mmDeleteStockItem.DeleteStockItemMock.mutex.Lock()
	mmDeleteStockItem.DeleteStockItemMock.callArgs = append(mmDeleteStockItem.DeleteStockItemMock.callArgs, &mm_params)
	mmDeleteStockItem.DeleteStockItemMock.mutex.Unlock()

	for _, e := range mmDeleteStockItem.DeleteStockItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteStockItem.DeleteStockItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.paramPtrs

		mm_got := StockServiceUseCaseMockDeleteStockItemParams{ctx, userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteStockItem.t.Errorf("StockServiceUseCaseMock.DeleteStockItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteStockItem.t.Errorf("StockServiceUseCaseMock.DeleteStockItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteStockItem.t.Errorf("StockServiceUseCaseMock.DeleteStockItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteStockItem.t.Errorf("StockServiceUseCaseMock.DeleteStockItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteStockItem.DeleteStockItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteStockItem.t.Fatal("No results are set for the StockServiceUseCaseMock.DeleteStockItem")
		}
		return (*mm_results).err
	}
	if mmDeleteStockItem.funcDeleteStockItem != nil {
		return mmDeleteStockItem.funcDeleteStockItem(ctx, userID, skuID)
	}
	mmDeleteStockItem.t.Fatalf("Unexpected call to StockServiceUseCaseMock.DeleteStockItem. %v %v %v", ctx, userID, skuID)
	return
}

// DeleteStockItemAfterCounter returns a count of finished StockServiceUseCaseMock.DeleteStockItem invocations
func (mmDeleteStockItem *StockServiceUseCaseMock) DeleteStockItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockItem.afterDeleteStockItemCounter)
}

// DeleteStockItemBeforeCounter returns a count of StockServiceUseCaseMock.DeleteStockItem invocations
func (mmDeleteStockItem *StockServiceUseCaseMock) DeleteStockItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteStockItem.beforeDeleteStockItemCounter)
}

// Calls returns a list of arguments used in each call to StockServiceUseCaseMock.DeleteStockItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteStockItem *mStockServiceUseCaseMockDeleteStockItem) Calls() []*StockServiceUseCaseMockDeleteStockItemParams {
	mmDeleteStockItem.mutex.RLock()

	argCopy := make([]*StockServiceUseCaseMockDeleteStockItemParams, len(mmDeleteStockItem.callArgs))
	copy(argCopy, mmDeleteStockItem.callArgs)

	mmDeleteStockItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteStockItemDone returns true if the count of the DeleteStockItem invocations corresponds
// the number of defined expectations
func (m *StockServiceUseCaseMock) MinimockDeleteStockItemDone() bool {
	if m.DeleteStockItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteStockItemMock.invocationsDone()
}

// MinimockDeleteStockItemInspect logs each unmet expectation
func (m *StockServiceUseCaseMock) MinimockDeleteStockItemInspect() {
	for _, e := range m.DeleteStockItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.DeleteStockItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteStockItemCounter := mm_atomic.LoadUint64(&m.afterDeleteStockItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteStockItemMock.defaultExpectation != nil && afterDeleteStockItemCounter < 1 {
		if m.DeleteStockItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.DeleteStockItem at\n%s", m.DeleteStockItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.DeleteStockItem at\n%s with params: %#v", m.DeleteStockItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteStockItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteStockItem != nil && afterDeleteStockItemCounter < 1 {
		m.t.Errorf("Expected call to StockServiceUseCaseMock.DeleteStockItem at\n%s", m.funcDeleteStockItemOrigin)
	}

	if !m.DeleteStockItemMock.invocationsDone() && afterDeleteStockItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceUseCaseMock.DeleteStockItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteStockItemMock.expectedInvocations), m.DeleteStockItemMock.expectedInvocationsOrigin, afterDeleteStockItemCounter)
	}
}

type mStockServiceUseCaseMockGetStockItemBySKU struct {
	optional           bool
	mock               *StockServiceUseCaseMock
	defaultExpectation *StockServiceUseCaseMockGetStockItemBySKUExpectation
	expectations       []*StockServiceUseCaseMockGetStockItemBySKUExpectation

	callArgs []*StockServiceUseCaseMockGetStockItemBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceUseCaseMockGetStockItemBySKUExpectation specifies expectation struct of the StockServiceUseCase.GetStockItemBySKU
type StockServiceUseCaseMockGetStockItemBySKUExpectation struct {
	mock               *StockServiceUseCaseMock
	params             *StockServiceUseCaseMockGetStockItemBySKUParams
	paramPtrs          *StockServiceUseCaseMockGetStockItemBySKUParamPtrs
	expectationOrigins StockServiceUseCaseMockGetStockItemBySKUExpectationOrigins
	results            *StockServiceUseCaseMockGetStockItemBySKUResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceUseCaseMockGetStockItemBySKUParams contains parameters of the StockServiceUseCase.GetStockItemBySKU
type StockServiceUseCaseMockGetStockItemBySKUParams struct {
	ctx   context.Context
	skuID domain.SKUID
}

// StockServiceUseCaseMockGetStockItemBySKUParamPtrs contains pointers to parameters of the StockServiceUseCase.GetStockItemBySKU
type StockServiceUseCaseMockGetStockItemBySKUParamPtrs struct {
	ctx   *context.Context
	skuID *domain.SKUID
}

// StockServiceUseCaseMockGetStockItemBySKUResults contains results of the StockServiceUseCase.GetStockItemBySKU
type StockServiceUseCaseMockGetStockItemBySKUResults struct {
	s1  domain.StockItem
	err error
}

// StockServiceUseCaseMockGetStockItemBySKUOrigins contains origins of expectations of the StockServiceUseCase.GetStockItemBySKU
type StockServiceUseCaseMockGetStockItemBySKUExpectationOrigins struct {
	origin      string
	originCtx   string
	originSkuID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Optional() *mStockServiceUseCaseMockGetStockItemBySKU {
	mmGetStockItemBySKU.optional = true
	return mmGetStockItemBySKU
}

// Expect sets up expected params for StockServiceUseCase.GetStockItemBySKU
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Expect(ctx context.Context, skuID domain.SKUID) *mStockServiceUseCaseMockGetStockItemBySKU {
	if mmGetStockItemBySKU.mock.funcGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Set")
	}

	if mmGetStockItemBySKU.defaultExpectation == nil {
		mmGetStockItemBySKU.defaultExpectation = &StockServiceUseCaseMockGetStockItemBySKUExpectation{}
	}

	if mmGetStockItemBySKU.defaultExpectation.paramPtrs != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by ExpectParams functions")
	}

	mmGetStockItemBySKU.defaultExpectation.params = &StockServiceUseCaseMockGetStockItemBySKUParams{ctx, skuID}
	mmGetStockItemBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetStockItemBySKU.expectations {
		if minimock.Equal(e.params, mmGetStockItemBySKU.defaultExpectation.params) {
			mmGetStockItemBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStockItemBySKU.defaultExpectation.params)
		}
	}

	return mmGetStockItemBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceUseCase.GetStockItemBySKU
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) ExpectCtxParam1(ctx context.Context) *mStockServiceUseCaseMockGetStockItemBySKU {
	if mmGetStockItemBySKU.mock.funcGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Set")
	}

	if mmGetStockItemBySKU.defaultExpectation == nil {
		mmGetStockItemBySKU.defaultExpectation = &StockServiceUseCaseMockGetStockItemBySKUExpectation{}
	}

	if mmGetStockItemBySKU.defaultExpectation.params != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Expect")
	}

	if mmGetStockItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetStockItemBySKU.defaultExpectation.paramPtrs = &StockServiceUseCaseMockGetStockItemBySKUParamPtrs{}
	}
	mmGetStockItemBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetStockItemBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetStockItemBySKU
}

// ExpectSkuIDParam2 sets up expected param skuID for StockServiceUseCase.GetStockItemBySKU
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) ExpectSkuIDParam2(skuID domain.SKUID) *mStockServiceUseCaseMockGetStockItemBySKU {
	if mmGetStockItemBySKU.mock.funcGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Set")
	}

	if mmGetStockItemBySKU.defaultExpectation == nil {
		mmGetStockItemBySKU.defaultExpectation = &StockServiceUseCaseMockGetStockItemBySKUExpectation{}
	}

	if mmGetStockItemBySKU.defaultExpectation.params != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Expect")
	}

	if mmGetStockItemBySKU.defaultExpectation.paramPtrs == nil {
		mmGetStockItemBySKU.defaultExpectation.paramPtrs = &StockServiceUseCaseMockGetStockItemBySKUParamPtrs{}
	}
	mmGetStockItemBySKU.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetStockItemBySKU.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetStockItemBySKU
}

// Inspect accepts an inspector function that has same arguments as the StockServiceUseCase.GetStockItemBySKU
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Inspect(f func(ctx context.Context, skuID domain.SKUID)) *mStockServiceUseCaseMockGetStockItemBySKU {
	if mmGetStockItemBySKU.mock.inspectFuncGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("Inspect function is already set for StockServiceUseCaseMock.GetStockItemBySKU")
	}

	mmGetStockItemBySKU.mock.inspectFuncGetStockItemBySKU = f

	return mmGetStockItemBySKU
}

// Return sets up results that will be returned by StockServiceUseCase.GetStockItemBySKU
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Return(s1 domain.StockItem, err error) *StockServiceUseCaseMock {
	if mmGetStockItemBySKU.mock.funcGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Set")
	}

	if mmGetStockItemBySKU.defaultExpectation == nil {
		mmGetStockItemBySKU.defaultExpectation = &StockServiceUseCaseMockGetStockItemBySKUExpectation{mock: mmGetStockItemBySKU.mock}
	}
	mmGetStockItemBySKU.defaultExpectation.results = &StockServiceUseCaseMockGetStockItemBySKUResults{s1, err}
	mmGetStockItemBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySKU.mock
}

// Set uses given function f to mock the StockServiceUseCase.GetStockItemBySKU method
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Set(f func(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error)) *StockServiceUseCaseMock {
	if mmGetStockItemBySKU.defaultExpectation != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("Default expectation is already set for the StockServiceUseCase.GetStockItemBySKU method")
	}

	if len(mmGetStockItemBySKU.expectations) > 0 {
		mmGetStockItemBySKU.mock.t.Fatalf("Some expectations are already set for the StockServiceUseCase.GetStockItemBySKU method")
	}

	mmGetStockItemBySKU.mock.funcGetStockItemBySKU = f
	mmGetStockItemBySKU.mock.funcGetStockItemBySKUOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySKU.mock
}

// When sets expectation for the StockServiceUseCase.GetStockItemBySKU which will trigger the result defined by the following
// Then helper
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) When(ctx context.Context, skuID domain.SKUID) *StockServiceUseCaseMockGetStockItemBySKUExpectation {
	if mmGetStockItemBySKU.mock.funcGetStockItemBySKU != nil {
		mmGetStockItemBySKU.mock.t.Fatalf("StockServiceUseCaseMock.GetStockItemBySKU mock is already set by Set")
	}

	expectation := &StockServiceUseCaseMockGetStockItemBySKUExpectation{
		mock:               mmGetStockItemBySKU.mock,
		params:             &StockServiceUseCaseMockGetStockItemBySKUParams{ctx, skuID},
		expectationOrigins: StockServiceUseCaseMockGetStockItemBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetStockItemBySKU.expectations = append(mmGetStockItemBySKU.expectations, expectation)
	return expectation
}

// Then sets up StockServiceUseCase.GetStockItemBySKU return parameters for the expectation previously defined by the When method
func (e *StockServiceUseCaseMockGetStockItemBySKUExpectation) Then(s1 domain.StockItem, err error) *StockServiceUseCaseMock {
	e.results = &StockServiceUseCaseMockGetStockItemBySKUResults{s1, err}
	return e.mock
}

// Times sets number of times StockServiceUseCase.GetStockItemBySKU should be invoked
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Times(n uint64) *mStockServiceUseCaseMockGetStockItemBySKU {
	if n == 0 {
		mmGetStockItemBySKU.mock.t.Fatalf("Times of StockServiceUseCaseMock.GetStockItemBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStockItemBySKU.expectedInvocations, n)
	mmGetStockItemBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStockItemBySKU
}

func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) invocationsDone() bool {
	if len(mmGetStockItemBySKU.expectations) == 0 && mmGetStockItemBySKU.defaultExpectation == nil && mmGetStockItemBySKU.mock.funcGetStockItemBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStockItemBySKU.mock.afterGetStockItemBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStockItemBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStockItemBySKU implements mm_usecase.StockServiceUseCase
func (mmGetStockItemBySKU *StockServiceUseCaseMock) GetStockItemBySKU(ctx context.Context, skuID domain.SKUID) (s1 domain.StockItem, err error) {
	mm_atomic.AddUint64(&mmGetStockItemBySKU.beforeGetStockItemBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStockItemBySKU.afterGetStockItemBySKUCounter, 1)

	mmGetStockItemBySKU.t.Helper()

	if mmGetStockItemBySKU.inspectFuncGetStockItemBySKU != nil {
		mmGetStockItemBySKU.inspectFuncGetStockItemBySKU(ctx, skuID)
	}

	mm_params := StockServiceUseCaseMockGetStockItemBySKUParams{ctx, skuID}

	// Record call args
	mmGetStockItemBySKU.GetStockItemBySKUMock.mutex.Lock()
	mmGetStockItemBySKU.GetStockItemBySKUMock.callArgs = append(mmGetStockItemBySKU.GetStockItemBySKUMock.callArgs, &mm_params)
	mmGetStockItemBySKU.GetStockItemBySKUMock.mutex.Unlock()

	for _, e := range mmGetStockItemBySKU.GetStockItemBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.paramPtrs

		mm_got := StockServiceUseCaseMockGetStockItemBySKUParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetStockItemBySKU.t.Errorf("StockServiceUseCaseMock.GetStockItemBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetStockItemBySKU.t.Errorf("StockServiceUseCaseMock.GetStockItemBySKU got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStockItemBySKU.t.Errorf("StockServiceUseCaseMock.GetStockItemBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStockItemBySKU.GetStockItemBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStockItemBySKU.t.Fatal("No results are set for the StockServiceUseCaseMock.GetStockItemBySKU")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetStockItemBySKU.funcGetStockItemBySKU != nil {
		return mmGetStockItemBySKU.funcGetStockItemBySKU(ctx, skuID)
	}
	mmGetStockItemBySKU.t.Fatalf("Unexpected call to StockServiceUseCaseMock.GetStockItemBySKU. %v %v", ctx, skuID)
	return
}

// GetStockItemBySKUAfterCounter returns a count of finished StockServiceUseCaseMock.GetStockItemBySKU invocations
func (mmGetStockItemBySKU *StockServiceUseCaseMock) GetStockItemBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItemBySKU.afterGetStockItemBySKUCounter)
}

// GetStockItemBySKUBeforeCounter returns a count of StockServiceUseCaseMock.GetStockItemBySKU invocations
func (mmGetStockItemBySKU *StockServiceUseCaseMock) GetStockItemBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStockItemBySKU.beforeGetStockItemBySKUCounter)
}

// Calls returns a list of arguments used in each call to StockServiceUseCaseMock.GetStockItemBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStockItemBySKU *mStockServiceUseCaseMockGetStockItemBySKU) Calls() []*StockServiceUseCaseMockGetStockItemBySKUParams {
	mmGetStockItemBySKU.mutex.RLock()

	argCopy := make([]*StockServiceUseCaseMockGetStockItemBySKUParams, len(mmGetStockItemBySKU.callArgs))
	copy(argCopy, mmGetStockItemBySKU.callArgs)

	mmGetStockItemBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetStockItemBySKUDone returns true if the count of the GetStockItemBySKU invocations corresponds
// the number of defined expectations
func (m *StockServiceUseCaseMock) MinimockGetStockItemBySKUDone() bool {
	if m.GetStockItemBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStockItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStockItemBySKUMock.invocationsDone()
}

// MinimockGetStockItemBySKUInspect logs each unmet expectation
func (m *StockServiceUseCaseMock) MinimockGetStockItemBySKUInspect() {
	for _, e := range m.GetStockItemBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.GetStockItemBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetStockItemBySKUCounter := mm_atomic.LoadUint64(&m.afterGetStockItemBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStockItemBySKUMock.defaultExpectation != nil && afterGetStockItemBySKUCounter < 1 {
		if m.GetStockItemBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.GetStockItemBySKU at\n%s", m.GetStockItemBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.GetStockItemBySKU at\n%s with params: %#v", m.GetStockItemBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetStockItemBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStockItemBySKU != nil && afterGetStockItemBySKUCounter < 1 {
		m.t.Errorf("Expected call to StockServiceUseCaseMock.GetStockItemBySKU at\n%s", m.funcGetStockItemBySKUOrigin)
	}

	if !m.GetStockItemBySKUMock.invocationsDone() && afterGetStockItemBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceUseCaseMock.GetStockItemBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStockItemBySKUMock.expectedInvocations), m.GetStockItemBySKUMock.expectedInvocationsOrigin, afterGetStockItemBySKUCounter)
	}
}

type mStockServiceUseCaseMockListStockItems struct {
	optional           bool
	mock               *StockServiceUseCaseMock
	defaultExpectation *StockServiceUseCaseMockListStockItemsExpectation
	expectations       []*StockServiceUseCaseMockListStockItemsExpectation

	callArgs []*StockServiceUseCaseMockListStockItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StockServiceUseCaseMockListStockItemsExpectation specifies expectation struct of the StockServiceUseCase.ListStockItems
type StockServiceUseCaseMockListStockItemsExpectation struct {
	mock               *StockServiceUseCaseMock
	params             *StockServiceUseCaseMockListStockItemsParams
	paramPtrs          *StockServiceUseCaseMockListStockItemsParamPtrs
	expectationOrigins StockServiceUseCaseMockListStockItemsExpectationOrigins
	results            *StockServiceUseCaseMockListStockItemsResults
	returnOrigin       string
	Counter            uint64
}

// StockServiceUseCaseMockListStockItemsParams contains parameters of the StockServiceUseCase.ListStockItems
type StockServiceUseCaseMockListStockItemsParams struct {
	ctx    context.Context
	filter domain.Filter
}

// StockServiceUseCaseMockListStockItemsParamPtrs contains pointers to parameters of the StockServiceUseCase.ListStockItems
type StockServiceUseCaseMockListStockItemsParamPtrs struct {
	ctx    *context.Context
	filter *domain.Filter
}

// StockServiceUseCaseMockListStockItemsResults contains results of the StockServiceUseCase.ListStockItems
type StockServiceUseCaseMockListStockItemsResults struct {
	p1  domain.PaginatedResponse[domain.StockItem]
	err error
}

// StockServiceUseCaseMockListStockItemsOrigins contains origins of expectations of the StockServiceUseCase.ListStockItems
type StockServiceUseCaseMockListStockItemsExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Optional() *mStockServiceUseCaseMockListStockItems {
	mmListStockItems.optional = true
	return mmListStockItems
}

// Expect sets up expected params for StockServiceUseCase.ListStockItems
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Expect(ctx context.Context, filter domain.Filter) *mStockServiceUseCaseMockListStockItems {
	if mmListStockItems.mock.funcListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Set")
	}

	if mmListStockItems.defaultExpectation == nil {
		mmListStockItems.defaultExpectation = &StockServiceUseCaseMockListStockItemsExpectation{}
	}

	if mmListStockItems.defaultExpectation.paramPtrs != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by ExpectParams functions")
	}

	mmListStockItems.defaultExpectation.params = &StockServiceUseCaseMockListStockItemsParams{ctx, filter}
	mmListStockItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListStockItems.expectations {
		if minimock.Equal(e.params, mmListStockItems.defaultExpectation.params) {
			mmListStockItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListStockItems.defaultExpectation.params)
		}
	}

	return mmListStockItems
}

// ExpectCtxParam1 sets up expected param ctx for StockServiceUseCase.ListStockItems
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) ExpectCtxParam1(ctx context.Context) *mStockServiceUseCaseMockListStockItems {
	if mmListStockItems.mock.funcListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Set")
	}

	if mmListStockItems.defaultExpectation == nil {
		mmListStockItems.defaultExpectation = &StockServiceUseCaseMockListStockItemsExpectation{}
	}

	if mmListStockItems.defaultExpectation.params != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Expect")
	}

	if mmListStockItems.defaultExpectation.paramPtrs == nil {
		mmListStockItems.defaultExpectation.paramPtrs = &StockServiceUseCaseMockListStockItemsParamPtrs{}
	}
	mmListStockItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmListStockItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListStockItems
}

// ExpectFilterParam2 sets up expected param filter for StockServiceUseCase.ListStockItems
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) ExpectFilterParam2(filter domain.Filter) *mStockServiceUseCaseMockListStockItems {
	if mmListStockItems.mock.funcListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Set")
	}

	if mmListStockItems.defaultExpectation == nil {
		mmListStockItems.defaultExpectation = &StockServiceUseCaseMockListStockItemsExpectation{}
	}

	if mmListStockItems.defaultExpectation.params != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Expect")
	}

	if mmListStockItems.defaultExpectation.paramPtrs == nil {
		mmListStockItems.defaultExpectation.paramPtrs = &StockServiceUseCaseMockListStockItemsParamPtrs{}
	}
	mmListStockItems.defaultExpectation.paramPtrs.filter = &filter
	mmListStockItems.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListStockItems
}

// Inspect accepts an inspector function that has same arguments as the StockServiceUseCase.ListStockItems
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Inspect(f func(ctx context.Context, filter domain.Filter)) *mStockServiceUseCaseMockListStockItems {
	if mmListStockItems.mock.inspectFuncListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("Inspect function is already set for StockServiceUseCaseMock.ListStockItems")
	}

	mmListStockItems.mock.inspectFuncListStockItems = f

	return mmListStockItems
}

// Return sets up results that will be returned by StockServiceUseCase.ListStockItems
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Return(p1 domain.PaginatedResponse[domain.StockItem], err error) *StockServiceUseCaseMock {
	if mmListStockItems.mock.funcListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Set")
	}

	if mmListStockItems.defaultExpectation == nil {
		mmListStockItems.defaultExpectation = &StockServiceUseCaseMockListStockItemsExpectation{mock: mmListStockItems.mock}
	}
	mmListStockItems.defaultExpectation.results = &StockServiceUseCaseMockListStockItemsResults{p1, err}
	mmListStockItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListStockItems.mock
}

// Set uses given function f to mock the StockServiceUseCase.ListStockItems method
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Set(f func(ctx context.Context, filter domain.Filter) (p1 domain.PaginatedResponse[domain.StockItem], err error)) *StockServiceUseCaseMock {
	if mmListStockItems.defaultExpectation != nil {
		mmListStockItems.mock.t.Fatalf("Default expectation is already set for the StockServiceUseCase.ListStockItems method")
	}

	if len(mmListStockItems.expectations) > 0 {
		mmListStockItems.mock.t.Fatalf("Some expectations are already set for the StockServiceUseCase.ListStockItems method")
	}

	mmListStockItems.mock.funcListStockItems = f
	mmListStockItems.mock.funcListStockItemsOrigin = minimock.CallerInfo(1)
	return mmListStockItems.mock
}

// When sets expectation for the StockServiceUseCase.ListStockItems which will trigger the result defined by the following
// Then helper
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) When(ctx context.Context, filter domain.Filter) *StockServiceUseCaseMockListStockItemsExpectation {
	if mmListStockItems.mock.funcListStockItems != nil {
		mmListStockItems.mock.t.Fatalf("StockServiceUseCaseMock.ListStockItems mock is already set by Set")
	}

	expectation := &StockServiceUseCaseMockListStockItemsExpectation{
		mock:               mmListStockItems.mock,
		params:             &StockServiceUseCaseMockListStockItemsParams{ctx, filter},
		expectationOrigins: StockServiceUseCaseMockListStockItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListStockItems.expectations = append(mmListStockItems.expectations, expectation)
	return expectation
}

// Then sets up StockServiceUseCase.ListStockItems return parameters for the expectation previously defined by the When method
func (e *StockServiceUseCaseMockListStockItemsExpectation) Then(p1 domain.PaginatedResponse[domain.StockItem], err error) *StockServiceUseCaseMock {
	e.results = &StockServiceUseCaseMockListStockItemsResults{p1, err}
	return e.mock
}

// Times sets number of times StockServiceUseCase.ListStockItems should be invoked
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Times(n uint64) *mStockServiceUseCaseMockListStockItems {
	if n == 0 {
		mmListStockItems.mock.t.Fatalf("Times of StockServiceUseCaseMock.ListStockItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListStockItems.expectedInvocations, n)
	mmListStockItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListStockItems
}

func (mmListStockItems *mStockServiceUseCaseMockListStockItems) invocationsDone() bool {
	if len(mmListStockItems.expectations) == 0 && mmListStockItems.defaultExpectation == nil && mmListStockItems.mock.funcListStockItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListStockItems.mock.afterListStockItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListStockItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListStockItems implements mm_usecase.StockServiceUseCase
func (mmListStockItems *StockServiceUseCaseMock) ListStockItems(ctx context.Context, filter domain.Filter) (p1 domain.PaginatedResponse[domain.StockItem], err error) {
	mm_atomic.AddUint64(&mmListStockItems.beforeListStockItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmListStockItems.afterListStockItemsCounter, 1)

	mmListStockItems.t.Helper()

	if mmListStockItems.inspectFuncListStockItems != nil {
		mmListStockItems.inspectFuncListStockItems(ctx, filter)
	}

	mm_params := StockServiceUseCaseMockListStockItemsParams{ctx, filter}

	// Record call args
	mmListStockItems.ListStockItemsMock.mutex.Lock()
	mmListStockItems.ListStockItemsMock.callArgs = append(mmListStockItems.ListStockItemsMock.callArgs, &mm_params)
	mmListStockItems.ListStockItemsMock.mutex.Unlock()

	for _, e := range mmListStockItems.ListStockItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmListStockItems.ListStockItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListStockItems.ListStockItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmListStockItems.ListStockItemsMock.defaultExpectation.params
		mm_want_ptrs := mmListStockItems.ListStockItemsMock.defaultExpectation.paramPtrs

		mm_got := StockServiceUseCaseMockListStockItemsParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListStockItems.t.Errorf("StockServiceUseCaseMock.ListStockItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListStockItems.ListStockItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListStockItems.t.Errorf("StockServiceUseCaseMock.ListStockItems got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListStockItems.ListStockItemsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListStockItems.t.Errorf("StockServiceUseCaseMock.ListStockItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListStockItems.ListStockItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListStockItems.ListStockItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmListStockItems.t.Fatal("No results are set for the StockServiceUseCaseMock.ListStockItems")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmListStockItems.funcListStockItems != nil {
		return mmListStockItems.funcListStockItems(ctx, filter)
	}
	mmListStockItems.t.Fatalf("Unexpected call to StockServiceUseCaseMock.ListStockItems. %v %v", ctx, filter)
	return
}

// ListStockItemsAfterCounter returns a count of finished StockServiceUseCaseMock.ListStockItems invocations
func (mmListStockItems *StockServiceUseCaseMock) ListStockItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStockItems.afterListStockItemsCounter)
}

// ListStockItemsBeforeCounter returns a count of StockServiceUseCaseMock.ListStockItems invocations
func (mmListStockItems *StockServiceUseCaseMock) ListStockItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListStockItems.beforeListStockItemsCounter)
}

// Calls returns a list of arguments used in each call to StockServiceUseCaseMock.ListStockItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListStockItems *mStockServiceUseCaseMockListStockItems) Calls() []*StockServiceUseCaseMockListStockItemsParams {
	mmListStockItems.mutex.RLock()

	argCopy := make([]*StockServiceUseCaseMockListStockItemsParams, len(mmListStockItems.callArgs))
	copy(argCopy, mmListStockItems.callArgs)

	mmListStockItems.mutex.RUnlock()

	return argCopy
}

// MinimockListStockItemsDone returns true if the count of the ListStockItems invocations corresponds
// the number of defined expectations
func (m *StockServiceUseCaseMock) MinimockListStockItemsDone() bool {
	if m.ListStockItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListStockItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListStockItemsMock.invocationsDone()
}

// MinimockListStockItemsInspect logs each unmet expectation
func (m *StockServiceUseCaseMock) MinimockListStockItemsInspect() {
	for _, e := range m.ListStockItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.ListStockItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListStockItemsCounter := mm_atomic.LoadUint64(&m.afterListStockItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListStockItemsMock.defaultExpectation != nil && afterListStockItemsCounter < 1 {
		if m.ListStockItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.ListStockItems at\n%s", m.ListStockItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StockServiceUseCaseMock.ListStockItems at\n%s with params: %#v", m.ListStockItemsMock.defaultExpectation.expectationOrigins.origin, *m.ListStockItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListStockItems != nil && afterListStockItemsCounter < 1 {
		m.t.Errorf("Expected call to StockServiceUseCaseMock.ListStockItems at\n%s", m.funcListStockItemsOrigin)
	}

	if !m.ListStockItemsMock.invocationsDone() && afterListStockItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to StockServiceUseCaseMock.ListStockItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListStockItemsMock.expectedInvocations), m.ListStockItemsMock.expectedInvocationsOrigin, afterListStockItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockServiceUseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddStockItemInspect()

			m.MinimockDeleteStockItemInspect()

			m.MinimockGetStockItemBySKUInspect()

			m.MinimockListStockItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockServiceUseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockServiceUseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddStockItemDone() &&
		m.MinimockDeleteStockItemDone() &&
		m.MinimockGetStockItemBySKUDone() &&
		m.MinimockListStockItemsDone()
}
